class ParseError{constructor(e,t){let r=" "+e;let n;const o=t&&t.loc;if(o&&o.start<=o.end){const e=o.lexer.input;n=o.start;const t=o.end;if(n===e.length){r+=" at end of input: "}else{r+=" at position "+(n+1)+": "}const a=e.slice(n,t).replace(/[^]/g,"$&̲");let i;if(n>15){i="…"+e.slice(n-15,n)}else{i=e.slice(0,n)}let s;if(t+15<e.length){s=e.slice(t,t+15)+"…"}else{s=e.slice(t)}r+=i+a+s}const a=new Error(r);a.name="ParseError";a.__proto__=ParseError.prototype;a.position=n;return a}}ParseError.prototype.__proto__=Error.prototype;const deflt=function(e,t){return e===undefined?t:e};const uppercase=/([A-Z])/g;const hyphenate=function(e){return e.replace(uppercase,"-$1").toLowerCase()};const ESCAPE_LOOKUP={"&":"&amp;",">":"&gt;","<":"&lt;",'"':"&quot;","'":"&#x27;"};const ESCAPE_REGEX=/[&><"']/g;function escape(e){return String(e).replace(ESCAPE_REGEX,(e=>ESCAPE_LOOKUP[e]))}const getBaseElem=function(e){if(e.type==="ordgroup"){if(e.body.length===1){return getBaseElem(e.body[0])}else{return e}}else if(e.type==="color"){if(e.body.length===1){return getBaseElem(e.body[0])}else{return e}}else if(e.type==="font"){return getBaseElem(e.body)}else{return e}};const isCharacterBox=function(e){const t=getBaseElem(e);return t.type==="mathord"||t.type==="textord"||t.type==="atom"};const assert=function(e){if(!e){throw new Error("Expected non-null, but got "+String(e))}return e};const protocolFromUrl=function(e){const t=/^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(e);return t!=null?t[1]:"_relative"};const round=function(e){return+e.toFixed(4)};var utils={deflt:deflt,escape:escape,hyphenate:hyphenate,getBaseElem:getBaseElem,isCharacterBox:isCharacterBox,protocolFromUrl:protocolFromUrl,round:round};class Settings{constructor(e){e=e||{};this.displayMode=utils.deflt(e.displayMode,false);this.annotate=utils.deflt(e.annotate,false);this.leqno=utils.deflt(e.leqno,false);this.errorColor=utils.deflt(e.errorColor,"#b22222");this.macros=e.macros||{};this.wrap=utils.deflt(e.wrap,"none");this.xml=utils.deflt(e.xml,false);this.colorIsTextColor=utils.deflt(e.colorIsTextColor,false);this.strict=utils.deflt(e.strict,false);this.trust=utils.deflt(e.trust,false);this.maxSize=e.maxSize===undefined?[Infinity,Infinity]:Array.isArray(e.maxSize)?e.maxSize:[Infinity,Infinity];this.maxExpand=Math.max(0,utils.deflt(e.maxExpand,1e3))}isTrusted(e){if(e.url&&!e.protocol){e.protocol=utils.protocolFromUrl(e.url)}const t=typeof this.trust==="function"?this.trust(e):this.trust;return Boolean(t)}}const _functions={};const _mathmlGroupBuilders={};function defineFunction({type:e,names:t,props:r,handler:n,mathmlBuilder:o}){const a={type:e,numArgs:r.numArgs,argTypes:r.argTypes,allowedInArgument:!!r.allowedInArgument,allowedInText:!!r.allowedInText,allowedInMath:r.allowedInMath===undefined?true:r.allowedInMath,numOptionalArgs:r.numOptionalArgs||0,infix:!!r.infix,primitive:!!r.primitive,handler:n};for(let e=0;e<t.length;++e){_functions[t[e]]=a}if(e){if(o){_mathmlGroupBuilders[e]=o}}}function defineFunctionBuilders({type:e,mathmlBuilder:t}){defineFunction({type:e,names:[],props:{numArgs:0},handler(){throw new Error("Should never be called.")},mathmlBuilder:t})}const normalizeArgument=function(e){return e.type==="ordgroup"&&e.body.length===1?e.body[0]:e};const ordargument=function(e){return e.type==="ordgroup"?e.body:[e]};class DocumentFragment{constructor(e){this.children=e;this.classes=[];this.style={}}hasClass(e){return this.classes.includes(e)}toNode(){const e=document.createDocumentFragment();for(let t=0;t<this.children.length;t++){e.appendChild(this.children[t].toNode())}return e}toMarkup(){let e="";for(let t=0;t<this.children.length;t++){e+=this.children[t].toMarkup()}return e}toText(){const e=e=>e.toText();return this.children.map(e).join("")}}const createClass=function(e){return e.filter((e=>e)).join(" ")};const initNode=function(e,t){this.classes=e||[];this.attributes={};this.style=t||{}};const toNode=function(e){const t=document.createElement(e);t.className=createClass(this.classes);for(const e in this.style){if(Object.prototype.hasOwnProperty.call(this.style,e)){t.style[e]=this.style[e]}}for(const e in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,e)){t.setAttribute(e,this.attributes[e])}}for(let e=0;e<this.children.length;e++){t.appendChild(this.children[e].toNode())}return t};const toMarkup=function(e){let t=`<${e}`;if(this.classes.length){t+=` class="${utils.escape(createClass(this.classes))}"`}let r="";for(const e in this.style){if(Object.prototype.hasOwnProperty.call(this.style,e)){r+=`${utils.hyphenate(e)}:${this.style[e]};`}}if(r){t+=` style="${r}"`}for(const e in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,e)){t+=` ${e}="${utils.escape(this.attributes[e])}"`}}t+=">";for(let e=0;e<this.children.length;e++){t+=this.children[e].toMarkup()}t+=`</${e}>`;return t};class Span{constructor(e,t,r){initNode.call(this,e,r);this.children=t||[]}setAttribute(e,t){this.attributes[e]=t}toNode(){return toNode.call(this,"span")}toMarkup(){return toMarkup.call(this,"span")}}class TextNode$1{constructor(e){this.text=e}toNode(){return document.createTextNode(this.text)}toMarkup(){return utils.escape(this.text)}}class Img{constructor(e,t,r){this.alt=t;this.src=e;this.classes=["mord"];this.style=r}hasClass(e){return this.classes.includes(e)}toNode(){const e=document.createElement("img");e.src=this.src;e.alt=this.alt;e.className="mord";for(const t in this.style){if(Object.prototype.hasOwnProperty.call(this.style,t)){e.style[t]=this.style[t]}}return e}toMarkup(){let e=`<img src='${this.src}' alt='${this.alt}'`;let t="";for(const e in this.style){if(Object.prototype.hasOwnProperty.call(this.style,e)){t+=`${utils.hyphenate(e)}:${this.style[e]};`}}if(t){e+=` style="${utils.escape(t)}"`}e+="/>";return e}}function newDocumentFragment(e){return new DocumentFragment(e)}class MathNode{constructor(e,t,r,n){this.type=e;this.attributes={};this.children=t||[];this.classes=r||[];this.style=n||{}}setAttribute(e,t){this.attributes[e]=t}getAttribute(e){return this.attributes[e]}toNode(){const e=document.createElementNS("http://www.w3.org/1998/Math/MathML",this.type);for(const t in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,t)){e.setAttribute(t,this.attributes[t])}}if(this.classes.length>0){e.className=createClass(this.classes)}for(const t in this.style){if(Object.prototype.hasOwnProperty.call(this.style,t)){e.style[t]=this.style[t]}}for(let t=0;t<this.children.length;t++){e.appendChild(this.children[t].toNode())}return e}toMarkup(){let e="<"+this.type;for(const t in this.attributes){if(Object.prototype.hasOwnProperty.call(this.attributes,t)){e+=" "+t+'="';e+=utils.escape(this.attributes[t]);e+='"'}}if(this.classes.length>0){e+=` class="${utils.escape(createClass(this.classes))}"`}let t="";for(const e in this.style){if(Object.prototype.hasOwnProperty.call(this.style,e)){t+=`${utils.hyphenate(e)}:${this.style[e]};`}}if(t){e+=` style="${t}"`}e+=">";for(let t=0;t<this.children.length;t++){e+=this.children[t].toMarkup()}e+="</"+this.type+">";return e}toText(){return this.children.map((e=>e.toText())).join("")}}class TextNode{constructor(e){this.text=e}toNode(){return document.createTextNode(this.text)}toMarkup(){return utils.escape(this.toText())}toText(){return this.text}}const wrapWithMstyle=e=>{let t;if(e.length===1&&e[0].type==="mrow"){t=e.pop();t.type="mstyle"}else{t=new MathNode("mstyle",e)}return t};var mathMLTree={MathNode:MathNode,TextNode:TextNode,newDocumentFragment:newDocumentFragment};const stretchyCodePoint={widehat:"^",widecheck:"ˇ",widetilde:"~",wideparen:"⏜",utilde:"~",overleftarrow:"←",underleftarrow:"←",xleftarrow:"←",overrightarrow:"→",underrightarrow:"→",xrightarrow:"→",underbrace:"⏟",overbrace:"⏞",overgroup:"⏠",overparen:"⏜",undergroup:"⏡",underparen:"⏝",overleftrightarrow:"↔",underleftrightarrow:"↔",xleftrightarrow:"↔",Overrightarrow:"⇒",xRightarrow:"⇒",overleftharpoon:"↼",xleftharpoonup:"↼",overrightharpoon:"⇀",xrightharpoonup:"⇀",xLeftarrow:"⇐",xLeftrightarrow:"⇔",xhookleftarrow:"↩",xhookrightarrow:"↪",xmapsto:"↦",xrightharpoondown:"⇁",xleftharpoondown:"↽",xtwoheadleftarrow:"↞",xtwoheadrightarrow:"↠",xlongequal:"=",xrightleftarrows:"⇄",yields:"→",yieldsLeft:"←",mesomerism:"↔",longrightharpoonup:"⇀",longleftharpoondown:"↽",eqrightharpoonup:"⇀",eqleftharpoondown:"↽","\\cdrightarrow":"→","\\cdleftarrow":"←","\\cdlongequal":"="};const mathMLnode=function(e){const t=new mathMLTree.TextNode(stretchyCodePoint[e.slice(1)]);const r=new mathMLTree.MathNode("mo",[t]);r.setAttribute("stretchy","true");return r};var stretchy={mathMLnode:mathMLnode};const ATOMS={bin:1,close:1,inner:1,open:1,punct:1,rel:1};const NON_ATOMS={"accent-token":1,mathord:1,"op-token":1,spacing:1,textord:1};const symbols={math:{},text:{}};function defineSymbol(e,t,r,n,o){symbols[e][n]={group:t,replace:r};if(o&&r){symbols[e][r]=symbols[e][n]}}const math="math";const text="text";const accent="accent-token";const bin="bin";const close="close";const inner="inner";const mathord="mathord";const op="op-token";const open="open";const punct="punct";const rel="rel";const spacing="spacing";const textord="textord";defineSymbol(math,rel,"≡","\\equiv",true);defineSymbol(math,rel,"≺","\\prec",true);defineSymbol(math,rel,"≻","\\succ",true);defineSymbol(math,rel,"∼","\\sim",true);defineSymbol(math,rel,"⟂","\\perp",true);defineSymbol(math,rel,"⪯","\\preceq",true);defineSymbol(math,rel,"⪰","\\succeq",true);defineSymbol(math,rel,"≃","\\simeq",true);defineSymbol(math,rel,"≌","\\backcong",true);defineSymbol(math,rel,"|","\\mid",true);defineSymbol(math,rel,"≪","\\ll",true);defineSymbol(math,rel,"≫","\\gg",true);defineSymbol(math,rel,"≍","\\asymp",true);defineSymbol(math,rel,"∥","\\parallel");defineSymbol(math,rel,"⋈","\\bowtie",true);defineSymbol(math,rel,"⌣","\\smile",true);defineSymbol(math,rel,"⊑","\\sqsubseteq",true);defineSymbol(math,rel,"⊒","\\sqsupseteq",true);defineSymbol(math,rel,"≐","\\doteq",true);defineSymbol(math,rel,"⌢","\\frown",true);defineSymbol(math,rel,"∋","\\ni",true);defineSymbol(math,rel,"∌","\\notni",true);defineSymbol(math,rel,"∝","\\propto",true);defineSymbol(math,rel,"⊢","\\vdash",true);defineSymbol(math,rel,"⊣","\\dashv",true);defineSymbol(math,rel,"∋","\\owns");defineSymbol(math,rel,"≘","\\arceq",true);defineSymbol(math,rel,"≙","\\wedgeq",true);defineSymbol(math,rel,"≚","\\veeeq",true);defineSymbol(math,rel,"≛","\\stareq",true);defineSymbol(math,rel,"≝","\\eqdef",true);defineSymbol(math,rel,"≞","\\measeq",true);defineSymbol(math,rel,"≟","\\questeq",true);defineSymbol(math,rel,"≠","\\ne",true);defineSymbol(math,rel,"≠","\\neq");defineSymbol(math,rel,"∷","\\dblcolon",true);defineSymbol(math,rel,"≔","\\coloneqq",true);defineSymbol(math,rel,"≕","\\eqqcolon",true);defineSymbol(math,rel,"∹","\\eqcolon",true);defineSymbol(math,rel,"⩴","\\Coloneqq",true);defineSymbol(math,punct,".","\\ldotp");defineSymbol(math,punct,"·","\\cdotp");defineSymbol(math,textord,"#","\\#");defineSymbol(text,textord,"#","\\#");defineSymbol(math,textord,"&","\\&");defineSymbol(text,textord,"&","\\&");defineSymbol(math,textord,"ℵ","\\aleph",true);defineSymbol(math,textord,"∀","\\forall",true);defineSymbol(math,textord,"ℏ","\\hbar",true);defineSymbol(math,textord,"∃","\\exists",true);defineSymbol(math,textord,"∇","\\nabla",true);defineSymbol(math,textord,"♭","\\flat",true);defineSymbol(math,textord,"ℓ","\\ell",true);defineSymbol(math,textord,"♮","\\natural",true);defineSymbol(math,textord,"Å","\\AA",true);defineSymbol(text,textord,"Å","\\AA",true);defineSymbol(math,textord,"♣","\\clubsuit",true);defineSymbol(math,textord,"♧","\\varclubsuit",true);defineSymbol(math,textord,"℘","\\wp",true);defineSymbol(math,textord,"♯","\\sharp",true);defineSymbol(math,textord,"♢","\\diamondsuit",true);defineSymbol(math,textord,"♦","\\vardiamondsuit",true);defineSymbol(math,textord,"ℜ","\\Re",true);defineSymbol(math,textord,"♡","\\heartsuit",true);defineSymbol(math,textord,"♥","\\varheartsuit",true);defineSymbol(math,textord,"ℑ","\\Im",true);defineSymbol(math,textord,"♠","\\spadesuit",true);defineSymbol(math,textord,"♤","\\varspadesuit",true);defineSymbol(math,textord,"♀","\\female",true);defineSymbol(math,textord,"♂","\\male",true);defineSymbol(math,textord,"§","\\S",true);defineSymbol(text,textord,"§","\\S");defineSymbol(math,textord,"¶","\\P",true);defineSymbol(text,textord,"¶","\\P");defineSymbol(text,textord,"☺","\\smiley",true);defineSymbol(math,textord,"☺","\\smiley",true);defineSymbol(math,textord,"†","\\dag");defineSymbol(text,textord,"†","\\dag");defineSymbol(text,textord,"†","\\textdagger");defineSymbol(math,textord,"‡","\\ddag");defineSymbol(text,textord,"‡","\\ddag");defineSymbol(text,textord,"‡","\\textdaggerdbl");defineSymbol(math,close,"⎱","\\rmoustache",true);defineSymbol(math,open,"⎰","\\lmoustache",true);defineSymbol(math,close,"⟯","\\rgroup",true);defineSymbol(math,open,"⟮","\\lgroup",true);defineSymbol(math,bin,"∓","\\mp",true);defineSymbol(math,bin,"⊖","\\ominus",true);defineSymbol(math,bin,"⊎","\\uplus",true);defineSymbol(math,bin,"⊓","\\sqcap",true);defineSymbol(math,bin,"∗","\\ast");defineSymbol(math,bin,"⊔","\\sqcup",true);defineSymbol(math,bin,"◯","\\bigcirc",true);defineSymbol(math,bin,"∙","\\bullet",true);defineSymbol(math,bin,"‡","\\ddagger");defineSymbol(math,bin,"≀","\\wr",true);defineSymbol(math,bin,"⨿","\\amalg");defineSymbol(math,bin,"&","\\And");defineSymbol(math,rel,"⟵","\\longleftarrow",true);defineSymbol(math,rel,"⇐","\\Leftarrow",true);defineSymbol(math,rel,"⟸","\\Longleftarrow",true);defineSymbol(math,rel,"⟶","\\longrightarrow",true);defineSymbol(math,rel,"⇒","\\Rightarrow",true);defineSymbol(math,rel,"⟹","\\Longrightarrow",true);defineSymbol(math,rel,"↔","\\leftrightarrow",true);defineSymbol(math,rel,"⟷","\\longleftrightarrow",true);defineSymbol(math,rel,"⇔","\\Leftrightarrow",true);defineSymbol(math,rel,"⟺","\\Longleftrightarrow",true);defineSymbol(math,rel,"↤","\\mapsfrom",true);defineSymbol(math,rel,"↦","\\mapsto",true);defineSymbol(math,rel,"⟼","\\longmapsto",true);defineSymbol(math,rel,"↗","\\nearrow",true);defineSymbol(math,rel,"↩","\\hookleftarrow",true);defineSymbol(math,rel,"↪","\\hookrightarrow",true);defineSymbol(math,rel,"↘","\\searrow",true);defineSymbol(math,rel,"↼","\\leftharpoonup",true);defineSymbol(math,rel,"⇀","\\rightharpoonup",true);defineSymbol(math,rel,"↙","\\swarrow",true);defineSymbol(math,rel,"↽","\\leftharpoondown",true);defineSymbol(math,rel,"⇁","\\rightharpoondown",true);defineSymbol(math,rel,"↖","\\nwarrow",true);defineSymbol(math,rel,"⇌","\\rightleftharpoons",true);defineSymbol(math,mathord,"↯","\\lightning",true);defineSymbol(math,mathord,"‰","\\permil",true);defineSymbol(text,textord,"‰","\\permil");defineSymbol(math,rel,"≮","\\nless",true);defineSymbol(math,rel,"⪇","\\lneq",true);defineSymbol(math,rel,"≨","\\lneqq",true);defineSymbol(math,rel,"≨︀","\\lvertneqq");defineSymbol(math,rel,"⋦","\\lnsim",true);defineSymbol(math,rel,"⪉","\\lnapprox",true);defineSymbol(math,rel,"⊀","\\nprec",true);defineSymbol(math,rel,"⋠","\\npreceq",true);defineSymbol(math,rel,"⋨","\\precnsim",true);defineSymbol(math,rel,"⪹","\\precnapprox",true);defineSymbol(math,rel,"≁","\\nsim",true);defineSymbol(math,rel,"∤","\\nmid",true);defineSymbol(math,rel,"∤","\\nshortmid");defineSymbol(math,rel,"⊬","\\nvdash",true);defineSymbol(math,rel,"⊭","\\nvDash",true);defineSymbol(math,rel,"⋪","\\ntriangleleft");defineSymbol(math,rel,"⋬","\\ntrianglelefteq",true);defineSymbol(math,rel,"⊄","\\nsubset",true);defineSymbol(math,rel,"⊅","\\nsupset",true);defineSymbol(math,rel,"⊊","\\subsetneq",true);defineSymbol(math,rel,"⊊︀","\\varsubsetneq");defineSymbol(math,rel,"⫋","\\subsetneqq",true);defineSymbol(math,rel,"⫋︀","\\varsubsetneqq");defineSymbol(math,rel,"≯","\\ngtr",true);defineSymbol(math,rel,"⪈","\\gneq",true);defineSymbol(math,rel,"≩","\\gneqq",true);defineSymbol(math,rel,"≩︀","\\gvertneqq");defineSymbol(math,rel,"⋧","\\gnsim",true);defineSymbol(math,rel,"⪊","\\gnapprox",true);defineSymbol(math,rel,"⊁","\\nsucc",true);defineSymbol(math,rel,"⋡","\\nsucceq",true);defineSymbol(math,rel,"⋩","\\succnsim",true);defineSymbol(math,rel,"⪺","\\succnapprox",true);defineSymbol(math,rel,"≆","\\ncong",true);defineSymbol(math,rel,"∦","\\nparallel",true);defineSymbol(math,rel,"∦","\\nshortparallel");defineSymbol(math,rel,"⊯","\\nVDash",true);defineSymbol(math,rel,"⋫","\\ntriangleright");defineSymbol(math,rel,"⋭","\\ntrianglerighteq",true);defineSymbol(math,rel,"⊋","\\supsetneq",true);defineSymbol(math,rel,"⊋","\\varsupsetneq");defineSymbol(math,rel,"⫌","\\supsetneqq",true);defineSymbol(math,rel,"⫌︀","\\varsupsetneqq");defineSymbol(math,rel,"⊮","\\nVdash",true);defineSymbol(math,rel,"⪵","\\precneqq",true);defineSymbol(math,rel,"⪶","\\succneqq",true);defineSymbol(math,bin,"⊴","\\unlhd");defineSymbol(math,bin,"⊵","\\unrhd");defineSymbol(math,rel,"↚","\\nleftarrow",true);defineSymbol(math,rel,"↛","\\nrightarrow",true);defineSymbol(math,rel,"⇍","\\nLeftarrow",true);defineSymbol(math,rel,"⇏","\\nRightarrow",true);defineSymbol(math,rel,"↮","\\nleftrightarrow",true);defineSymbol(math,rel,"⇎","\\nLeftrightarrow",true);defineSymbol(math,rel,"△","\\vartriangle");defineSymbol(math,textord,"ℏ","\\hslash");defineSymbol(math,textord,"▽","\\triangledown");defineSymbol(math,textord,"◊","\\lozenge");defineSymbol(math,textord,"Ⓢ","\\circledS");defineSymbol(math,textord,"®","\\circledR",true);defineSymbol(text,textord,"®","\\circledR");defineSymbol(text,textord,"®","\\textregistered");defineSymbol(math,textord,"∡","\\measuredangle",true);defineSymbol(math,textord,"∄","\\nexists");defineSymbol(math,textord,"℧","\\mho");defineSymbol(math,textord,"Ⅎ","\\Finv",true);defineSymbol(math,textord,"⅁","\\Game",true);defineSymbol(math,textord,"‵","\\backprime");defineSymbol(math,textord,"▲","\\blacktriangle");defineSymbol(math,textord,"▼","\\blacktriangledown");defineSymbol(math,textord,"■","\\blacksquare");defineSymbol(math,textord,"⧫","\\blacklozenge");defineSymbol(math,textord,"★","\\bigstar");defineSymbol(math,textord,"∢","\\sphericalangle",true);defineSymbol(math,textord,"∁","\\complement",true);defineSymbol(math,textord,"ð","\\eth",true);defineSymbol(text,textord,"ð","ð");defineSymbol(math,textord,"╱","\\diagup");defineSymbol(math,textord,"╲","\\diagdown");defineSymbol(math,textord,"□","\\square");defineSymbol(math,textord,"□","\\Box");defineSymbol(math,textord,"◊","\\Diamond");defineSymbol(math,textord,"¥","\\yen",true);defineSymbol(text,textord,"¥","\\yen",true);defineSymbol(math,textord,"✓","\\checkmark",true);defineSymbol(text,textord,"✓","\\checkmark");defineSymbol(math,textord,"✗","\\ballotx",true);defineSymbol(text,textord,"✗","\\ballotx");defineSymbol(text,textord,"•","\\textbullet");defineSymbol(math,textord,"ℶ","\\beth",true);defineSymbol(math,textord,"ℸ","\\daleth",true);defineSymbol(math,textord,"ℷ","\\gimel",true);defineSymbol(math,textord,"ϝ","\\digamma",true);defineSymbol(math,textord,"ϰ","\\varkappa");defineSymbol(math,open,"⌜","\\ulcorner",true);defineSymbol(math,close,"⌝","\\urcorner",true);defineSymbol(math,open,"⌞","\\llcorner",true);defineSymbol(math,close,"⌟","\\lrcorner",true);defineSymbol(math,rel,"≦","\\leqq",true);defineSymbol(math,rel,"⩽","\\leqslant",true);defineSymbol(math,rel,"⪕","\\eqslantless",true);defineSymbol(math,rel,"≲","\\lesssim",true);defineSymbol(math,rel,"⪅","\\lessapprox",true);defineSymbol(math,rel,"≊","\\approxeq",true);defineSymbol(math,bin,"⋖","\\lessdot");defineSymbol(math,rel,"⋘","\\lll",true);defineSymbol(math,rel,"≶","\\lessgtr",true);defineSymbol(math,rel,"⋚","\\lesseqgtr",true);defineSymbol(math,rel,"⪋","\\lesseqqgtr",true);defineSymbol(math,rel,"≑","\\doteqdot");defineSymbol(math,rel,"≓","\\risingdotseq",true);defineSymbol(math,rel,"≒","\\fallingdotseq",true);defineSymbol(math,rel,"∽","\\backsim",true);defineSymbol(math,rel,"⋍","\\backsimeq",true);defineSymbol(math,rel,"⫅","\\subseteqq",true);defineSymbol(math,rel,"⋐","\\Subset",true);defineSymbol(math,rel,"⊏","\\sqsubset",true);defineSymbol(math,rel,"≼","\\preccurlyeq",true);defineSymbol(math,rel,"⋞","\\curlyeqprec",true);defineSymbol(math,rel,"≾","\\precsim",true);defineSymbol(math,rel,"⪷","\\precapprox",true);defineSymbol(math,rel,"⊲","\\vartriangleleft");defineSymbol(math,rel,"⊴","\\trianglelefteq");defineSymbol(math,rel,"⊨","\\vDash",true);defineSymbol(math,rel,"⊪","\\Vvdash",true);defineSymbol(math,rel,"⌣","\\smallsmile");defineSymbol(math,rel,"⌢","\\smallfrown");defineSymbol(math,rel,"≏","\\bumpeq",true);defineSymbol(math,rel,"≎","\\Bumpeq",true);defineSymbol(math,rel,"≧","\\geqq",true);defineSymbol(math,rel,"⩾","\\geqslant",true);defineSymbol(math,rel,"⪖","\\eqslantgtr",true);defineSymbol(math,rel,"≳","\\gtrsim",true);defineSymbol(math,rel,"⪆","\\gtrapprox",true);defineSymbol(math,bin,"⋗","\\gtrdot");defineSymbol(math,rel,"⋙","\\ggg",true);defineSymbol(math,rel,"≷","\\gtrless",true);defineSymbol(math,rel,"⋛","\\gtreqless",true);defineSymbol(math,rel,"⪌","\\gtreqqless",true);defineSymbol(math,rel,"≖","\\eqcirc",true);defineSymbol(math,rel,"≗","\\circeq",true);defineSymbol(math,rel,"≜","\\triangleq",true);defineSymbol(math,rel,"∼","\\thicksim");defineSymbol(math,rel,"≈","\\thickapprox");defineSymbol(math,rel,"⫆","\\supseteqq",true);defineSymbol(math,rel,"⋑","\\Supset",true);defineSymbol(math,rel,"⊐","\\sqsupset",true);defineSymbol(math,rel,"≽","\\succcurlyeq",true);defineSymbol(math,rel,"⋟","\\curlyeqsucc",true);defineSymbol(math,rel,"≿","\\succsim",true);defineSymbol(math,rel,"⪸","\\succapprox",true);defineSymbol(math,rel,"⊳","\\vartriangleright");defineSymbol(math,rel,"⊵","\\trianglerighteq");defineSymbol(math,rel,"⊩","\\Vdash",true);defineSymbol(math,rel,"∣","\\shortmid");defineSymbol(math,rel,"∥","\\shortparallel");defineSymbol(math,rel,"≬","\\between",true);defineSymbol(math,rel,"⋔","\\pitchfork",true);defineSymbol(math,rel,"∝","\\varpropto");defineSymbol(math,rel,"◀","\\blacktriangleleft");defineSymbol(math,rel,"∴","\\therefore",true);defineSymbol(math,rel,"∍","\\backepsilon");defineSymbol(math,rel,"▶","\\blacktriangleright");defineSymbol(math,rel,"∵","\\because",true);defineSymbol(math,rel,"⋘","\\llless");defineSymbol(math,rel,"⋙","\\gggtr");defineSymbol(math,bin,"⊲","\\lhd");defineSymbol(math,bin,"⊳","\\rhd");defineSymbol(math,rel,"≂","\\eqsim",true);defineSymbol(math,rel,"⋈","\\Join");defineSymbol(math,rel,"≑","\\Doteq",true);defineSymbol(math,rel,"⥽","\\strictif",true);defineSymbol(math,rel,"⥼","\\strictfi",true);defineSymbol(math,bin,"∔","\\dotplus",true);defineSymbol(math,bin,"∖","\\smallsetminus");defineSymbol(math,bin,"⋒","\\Cap",true);defineSymbol(math,bin,"⋓","\\Cup",true);defineSymbol(math,bin,"⩞","\\doublebarwedge",true);defineSymbol(math,bin,"⊟","\\boxminus",true);defineSymbol(math,bin,"⊞","\\boxplus",true);defineSymbol(math,bin,"⋇","\\divideontimes",true);defineSymbol(math,bin,"⋉","\\ltimes",true);defineSymbol(math,bin,"⋊","\\rtimes",true);defineSymbol(math,bin,"⋋","\\leftthreetimes",true);defineSymbol(math,bin,"⋌","\\rightthreetimes",true);defineSymbol(math,bin,"⋏","\\curlywedge",true);defineSymbol(math,bin,"⋎","\\curlyvee",true);defineSymbol(math,bin,"⊝","\\circleddash",true);defineSymbol(math,bin,"⊛","\\circledast",true);defineSymbol(math,bin,"⊺","\\intercal",true);defineSymbol(math,bin,"⋒","\\doublecap");defineSymbol(math,bin,"⋓","\\doublecup");defineSymbol(math,bin,"⊠","\\boxtimes",true);defineSymbol(math,rel,"⇢","\\dashrightarrow",true);defineSymbol(math,rel,"⇠","\\dashleftarrow",true);defineSymbol(math,rel,"⇇","\\leftleftarrows",true);defineSymbol(math,rel,"⇆","\\leftrightarrows",true);defineSymbol(math,rel,"⇚","\\Lleftarrow",true);defineSymbol(math,rel,"↞","\\twoheadleftarrow",true);defineSymbol(math,rel,"↢","\\leftarrowtail",true);defineSymbol(math,rel,"↫","\\looparrowleft",true);defineSymbol(math,rel,"⇋","\\leftrightharpoons",true);defineSymbol(math,rel,"↶","\\curvearrowleft",true);defineSymbol(math,rel,"↺","\\circlearrowleft",true);defineSymbol(math,rel,"↰","\\Lsh",true);defineSymbol(math,rel,"⇈","\\upuparrows",true);defineSymbol(math,rel,"↿","\\upharpoonleft",true);defineSymbol(math,rel,"⇃","\\downharpoonleft",true);defineSymbol(math,rel,"⊶","\\origof",true);defineSymbol(math,rel,"⊷","\\imageof",true);defineSymbol(math,rel,"⊸","\\multimap",true);defineSymbol(math,rel,"↭","\\leftrightsquigarrow",true);defineSymbol(math,rel,"⇉","\\rightrightarrows",true);defineSymbol(math,rel,"⇄","\\rightleftarrows",true);defineSymbol(math,rel,"↠","\\twoheadrightarrow",true);defineSymbol(math,rel,"↣","\\rightarrowtail",true);defineSymbol(math,rel,"↬","\\looparrowright",true);defineSymbol(math,rel,"↷","\\curvearrowright",true);defineSymbol(math,rel,"↻","\\circlearrowright",true);defineSymbol(math,rel,"↱","\\Rsh",true);defineSymbol(math,rel,"⇊","\\downdownarrows",true);defineSymbol(math,rel,"↾","\\upharpoonright",true);defineSymbol(math,rel,"⇂","\\downharpoonright",true);defineSymbol(math,rel,"⇝","\\rightsquigarrow",true);defineSymbol(math,rel,"⇝","\\leadsto");defineSymbol(math,rel,"⇛","\\Rrightarrow",true);defineSymbol(math,rel,"↾","\\restriction");defineSymbol(math,textord,"‘","`");defineSymbol(math,textord,"$","\\$");defineSymbol(text,textord,"$","\\$");defineSymbol(text,textord,"$","\\textdollar");defineSymbol(math,textord,"¢","\\cent");defineSymbol(text,textord,"¢","\\cent");defineSymbol(math,textord,"%","\\%");defineSymbol(text,textord,"%","\\%");defineSymbol(math,textord,"_","\\_");defineSymbol(text,textord,"_","\\_");defineSymbol(text,textord,"_","\\textunderscore");defineSymbol(text,textord,"␣","\\textvisiblespace",true);defineSymbol(math,textord,"∠","\\angle",true);defineSymbol(math,textord,"∞","\\infty",true);defineSymbol(math,textord,"′","\\prime");defineSymbol(math,textord,"△","\\triangle");defineSymbol(text,textord,"Α","\\Alpha",true);defineSymbol(text,textord,"Β","\\Beta",true);defineSymbol(text,textord,"Γ","\\Gamma",true);defineSymbol(text,textord,"Δ","\\Delta",true);defineSymbol(text,textord,"Ε","\\Epsilon",true);defineSymbol(text,textord,"Ζ","\\Zeta",true);defineSymbol(text,textord,"Η","\\Eta",true);defineSymbol(text,textord,"Θ","\\Theta",true);defineSymbol(text,textord,"Ι","\\Iota",true);defineSymbol(text,textord,"Κ","\\Kappa",true);defineSymbol(text,textord,"Λ","\\Lambda",true);defineSymbol(text,textord,"Μ","\\Mu",true);defineSymbol(text,textord,"Ν","\\Nu",true);defineSymbol(text,textord,"Ξ","\\Xi",true);defineSymbol(text,textord,"Ο","\\Omicron",true);defineSymbol(text,textord,"Π","\\Pi",true);defineSymbol(text,textord,"Ρ","\\Rho",true);defineSymbol(text,textord,"Σ","\\Sigma",true);defineSymbol(text,textord,"Τ","\\Tau",true);defineSymbol(text,textord,"Υ","\\Upsilon",true);defineSymbol(text,textord,"Φ","\\Phi",true);defineSymbol(text,textord,"Χ","\\Chi",true);defineSymbol(text,textord,"Ψ","\\Psi",true);defineSymbol(text,textord,"Ω","\\Omega",true);defineSymbol(math,mathord,"Α","\\Alpha",true);defineSymbol(math,mathord,"Β","\\Beta",true);defineSymbol(math,mathord,"Γ","\\Gamma",true);defineSymbol(math,mathord,"Δ","\\Delta",true);defineSymbol(math,mathord,"Ε","\\Epsilon",true);defineSymbol(math,mathord,"Ζ","\\Zeta",true);defineSymbol(math,mathord,"Η","\\Eta",true);defineSymbol(math,mathord,"Θ","\\Theta",true);defineSymbol(math,mathord,"Ι","\\Iota",true);defineSymbol(math,mathord,"Κ","\\Kappa",true);defineSymbol(math,mathord,"Λ","\\Lambda",true);defineSymbol(math,mathord,"Μ","\\Mu",true);defineSymbol(math,mathord,"Ν","\\Nu",true);defineSymbol(math,mathord,"Ξ","\\Xi",true);defineSymbol(math,mathord,"Ο","\\Omicron",true);defineSymbol(math,mathord,"Π","\\Pi",true);defineSymbol(math,mathord,"Ρ","\\Rho",true);defineSymbol(math,mathord,"Σ","\\Sigma",true);defineSymbol(math,mathord,"Τ","\\Tau",true);defineSymbol(math,mathord,"Υ","\\Upsilon",true);defineSymbol(math,mathord,"Φ","\\Phi",true);defineSymbol(math,mathord,"Χ","\\Chi",true);defineSymbol(math,mathord,"Ψ","\\Psi",true);defineSymbol(math,mathord,"Ω","\\Omega",true);defineSymbol(math,open,"¬","\\neg",true);defineSymbol(math,open,"¬","\\lnot");defineSymbol(math,textord,"⊤","\\top");defineSymbol(math,textord,"⊥","\\bot");defineSymbol(math,textord,"∅","\\emptyset");defineSymbol(math,textord,"ø","\\varnothing");defineSymbol(math,mathord,"α","\\alpha",true);defineSymbol(math,mathord,"β","\\beta",true);defineSymbol(math,mathord,"γ","\\gamma",true);defineSymbol(math,mathord,"δ","\\delta",true);defineSymbol(math,mathord,"ϵ","\\epsilon",true);defineSymbol(math,mathord,"ζ","\\zeta",true);defineSymbol(math,mathord,"η","\\eta",true);defineSymbol(math,mathord,"θ","\\theta",true);defineSymbol(math,mathord,"ι","\\iota",true);defineSymbol(math,mathord,"κ","\\kappa",true);defineSymbol(math,mathord,"λ","\\lambda",true);defineSymbol(math,mathord,"μ","\\mu",true);defineSymbol(math,mathord,"ν","\\nu",true);defineSymbol(math,mathord,"ξ","\\xi",true);defineSymbol(math,mathord,"ο","\\omicron",true);defineSymbol(math,mathord,"π","\\pi",true);defineSymbol(math,mathord,"ρ","\\rho",true);defineSymbol(math,mathord,"σ","\\sigma",true);defineSymbol(math,mathord,"τ","\\tau",true);defineSymbol(math,mathord,"υ","\\upsilon",true);defineSymbol(math,mathord,"ϕ","\\phi",true);defineSymbol(math,mathord,"χ","\\chi",true);defineSymbol(math,mathord,"ψ","\\psi",true);defineSymbol(math,mathord,"ω","\\omega",true);defineSymbol(math,mathord,"ε","\\varepsilon",true);defineSymbol(math,mathord,"ϑ","\\vartheta",true);defineSymbol(math,mathord,"ϖ","\\varpi",true);defineSymbol(math,mathord,"ϱ","\\varrho",true);defineSymbol(math,mathord,"ς","\\varsigma",true);defineSymbol(math,mathord,"φ","\\varphi",true);defineSymbol(math,mathord,"Ϙ","\\Coppa",true);defineSymbol(math,mathord,"ϙ","\\coppa",true);defineSymbol(math,mathord,"ϙ","\\varcoppa",true);defineSymbol(math,mathord,"Ϟ","\\Koppa",true);defineSymbol(math,mathord,"ϟ","\\koppa",true);defineSymbol(math,mathord,"Ϡ","\\Sampi",true);defineSymbol(math,mathord,"ϡ","\\sampi",true);defineSymbol(math,mathord,"Ϛ","\\Stigma",true);defineSymbol(math,mathord,"ϛ","\\stigma",true);defineSymbol(math,mathord,"⫫","\\Bot");defineSymbol(math,bin,"∗","∗",true);defineSymbol(math,bin,"+","+");defineSymbol(math,bin,"*","*");defineSymbol(math,bin,"⁄","⁄");defineSymbol(math,bin,"−","-",true);defineSymbol(math,bin,"⋅","\\cdot",true);defineSymbol(math,bin,"∘","\\circ",true);defineSymbol(math,bin,"÷","\\div",true);defineSymbol(math,bin,"±","\\pm",true);defineSymbol(math,bin,"×","\\times",true);defineSymbol(math,bin,"∩","\\cap",true);defineSymbol(math,bin,"∪","\\cup",true);defineSymbol(math,bin,"∖","\\setminus",true);defineSymbol(math,bin,"∧","\\land");defineSymbol(math,bin,"∨","\\lor");defineSymbol(math,bin,"∧","\\wedge",true);defineSymbol(math,bin,"∨","\\vee",true);defineSymbol(math,open,"⟦","\\llbracket",true);defineSymbol(math,close,"⟧","\\rrbracket",true);defineSymbol(math,open,"⟨","\\langle",true);defineSymbol(math,open,"|","\\lvert");defineSymbol(math,open,"‖","\\lVert");defineSymbol(math,textord,"!","\\oc");defineSymbol(math,textord,"?","\\wn");defineSymbol(math,textord,"↓","\\shpos");defineSymbol(math,textord,"↕","\\shift");defineSymbol(math,textord,"↑","\\shneg");defineSymbol(math,close,"?","?");defineSymbol(math,close,"!","!");defineSymbol(math,close,"‼","‼");defineSymbol(math,close,"⟩","\\rangle",true);defineSymbol(math,close,"|","\\rvert");defineSymbol(math,close,"‖","\\rVert");defineSymbol(math,open,"⦃","\\lBrace",true);defineSymbol(math,close,"⦄","\\rBrace",true);defineSymbol(math,rel,"=","\\equal",true);defineSymbol(math,rel,":",":");defineSymbol(math,rel,"≈","\\approx",true);defineSymbol(math,rel,"≅","\\cong",true);defineSymbol(math,rel,"≥","\\ge");defineSymbol(math,rel,"≥","\\geq",true);defineSymbol(math,rel,"←","\\gets");defineSymbol(math,rel,">","\\gt",true);defineSymbol(math,rel,"∈","\\in",true);defineSymbol(math,rel,"∉","\\notin",true);defineSymbol(math,rel,"","\\@not");defineSymbol(math,rel,"⊂","\\subset",true);defineSymbol(math,rel,"⊃","\\supset",true);defineSymbol(math,rel,"⊆","\\subseteq",true);defineSymbol(math,rel,"⊇","\\supseteq",true);defineSymbol(math,rel,"⊈","\\nsubseteq",true);defineSymbol(math,rel,"⊈","\\nsubseteqq");defineSymbol(math,rel,"⊉","\\nsupseteq",true);defineSymbol(math,rel,"⊉","\\nsupseteqq");defineSymbol(math,rel,"⊨","\\models");defineSymbol(math,rel,"←","\\leftarrow",true);defineSymbol(math,rel,"≤","\\le");defineSymbol(math,rel,"≤","\\leq",true);defineSymbol(math,rel,"<","\\lt",true);defineSymbol(math,rel,"→","\\rightarrow",true);defineSymbol(math,rel,"→","\\to");defineSymbol(math,rel,"≱","\\ngeq",true);defineSymbol(math,rel,"≱","\\ngeqq");defineSymbol(math,rel,"≱","\\ngeqslant");defineSymbol(math,rel,"≰","\\nleq",true);defineSymbol(math,rel,"≰","\\nleqq");defineSymbol(math,rel,"≰","\\nleqslant");defineSymbol(math,rel,"⫫","\\Perp",true);defineSymbol(math,spacing," ","\\ ");defineSymbol(math,spacing," ","\\space");defineSymbol(math,spacing," ","\\nobreakspace");defineSymbol(text,spacing," ","\\ ");defineSymbol(text,spacing," "," ");defineSymbol(text,spacing," ","\\space");defineSymbol(text,spacing," ","\\nobreakspace");defineSymbol(math,spacing,null,"\\nobreak");defineSymbol(math,spacing,null,"\\allowbreak");defineSymbol(math,punct,",",",");defineSymbol(text,punct,":",":");defineSymbol(math,punct,";",";");defineSymbol(math,bin,"⊼","\\barwedge",true);defineSymbol(math,bin,"⊻","\\veebar",true);defineSymbol(math,bin,"⊙","\\odot",true);defineSymbol(math,bin,"⊕","\\oplus",true);defineSymbol(math,bin,"⊗","\\otimes",true);defineSymbol(math,textord,"∂","\\partial",true);defineSymbol(math,bin,"⊘","\\oslash",true);defineSymbol(math,bin,"⊚","\\circledcirc",true);defineSymbol(math,bin,"⊡","\\boxdot",true);defineSymbol(math,bin,"△","\\bigtriangleup");defineSymbol(math,bin,"▽","\\bigtriangledown");defineSymbol(math,bin,"†","\\dagger");defineSymbol(math,bin,"⋄","\\diamond");defineSymbol(math,bin,"⋆","\\star");defineSymbol(math,bin,"◃","\\triangleleft");defineSymbol(math,bin,"▹","\\triangleright");defineSymbol(math,open,"{","\\{");defineSymbol(text,textord,"{","\\{");defineSymbol(text,textord,"{","\\textbraceleft");defineSymbol(math,close,"}","\\}");defineSymbol(text,textord,"}","\\}");defineSymbol(text,textord,"}","\\textbraceright");defineSymbol(math,open,"{","\\lbrace");defineSymbol(math,close,"}","\\rbrace");defineSymbol(math,open,"[","\\lbrack",true);defineSymbol(text,textord,"[","\\lbrack",true);defineSymbol(math,close,"]","\\rbrack",true);defineSymbol(text,textord,"]","\\rbrack",true);defineSymbol(math,open,"(","\\lparen",true);defineSymbol(math,close,")","\\rparen",true);defineSymbol(text,textord,"<","\\textless",true);defineSymbol(text,textord,">","\\textgreater",true);defineSymbol(math,open,"⌊","\\lfloor",true);defineSymbol(math,close,"⌋","\\rfloor",true);defineSymbol(math,open,"⌈","\\lceil",true);defineSymbol(math,close,"⌉","\\rceil",true);defineSymbol(math,textord,"\\","\\backslash");defineSymbol(math,textord,"|","|");defineSymbol(math,textord,"|","\\vert");defineSymbol(text,textord,"|","\\textbar",true);defineSymbol(math,textord,"‖","\\|");defineSymbol(math,textord,"‖","\\Vert");defineSymbol(text,textord,"‖","\\textbardbl");defineSymbol(text,textord,"~","\\textasciitilde");defineSymbol(text,textord,"\\","\\textbackslash");defineSymbol(text,textord,"^","\\textasciicircum");defineSymbol(math,rel,"↑","\\uparrow",true);defineSymbol(math,rel,"⇑","\\Uparrow",true);defineSymbol(math,rel,"↓","\\downarrow",true);defineSymbol(math,rel,"⇓","\\Downarrow",true);defineSymbol(math,rel,"↕","\\updownarrow",true);defineSymbol(math,rel,"⇕","\\Updownarrow",true);defineSymbol(math,op,"∐","\\coprod");defineSymbol(math,op,"⋁","\\bigvee");defineSymbol(math,op,"⋀","\\bigwedge");defineSymbol(math,op,"⨄","\\biguplus");defineSymbol(math,op,"⋂","\\bigcap");defineSymbol(math,op,"⋃","\\bigcup");defineSymbol(math,op,"∫","\\int");defineSymbol(math,op,"∫","\\intop");defineSymbol(math,op,"∬","\\iint");defineSymbol(math,op,"∭","\\iiint");defineSymbol(math,op,"∏","\\prod");defineSymbol(math,op,"∑","\\sum");defineSymbol(math,op,"⨂","\\bigotimes");defineSymbol(math,op,"⨁","\\bigoplus");defineSymbol(math,op,"⨀","\\bigodot");defineSymbol(math,op,"∮","\\oint");defineSymbol(math,op,"∯","\\oiint");defineSymbol(math,op,"∰","\\oiiint");defineSymbol(math,op,"∱","\\intclockwise");defineSymbol(math,op,"∲","\\varointclockwise");defineSymbol(math,op,"⨌","\\iiiint");defineSymbol(math,op,"⨍","\\intbar");defineSymbol(math,op,"⨎","\\intBar");defineSymbol(math,op,"⨏","\\fint");defineSymbol(math,op,"⨒","\\rppolint");defineSymbol(math,op,"⨓","\\scpolint");defineSymbol(math,op,"⨕","\\pointint");defineSymbol(math,op,"⨖","\\sqint");defineSymbol(math,op,"⨗","\\intlarhk");defineSymbol(math,op,"⨘","\\intx");defineSymbol(math,op,"⨙","\\intcap");defineSymbol(math,op,"⨚","\\intcup");defineSymbol(math,op,"⨅","\\bigsqcap");defineSymbol(math,op,"⨆","\\bigsqcup");defineSymbol(math,op,"∫","\\smallint");defineSymbol(text,inner,"…","\\textellipsis");defineSymbol(math,inner,"…","\\mathellipsis");defineSymbol(text,inner,"…","\\ldots",true);defineSymbol(math,inner,"…","\\ldots",true);defineSymbol(math,inner,"⋰","\\iddots",true);defineSymbol(math,inner,"⋯","\\@cdots",true);defineSymbol(math,inner,"⋱","\\ddots",true);defineSymbol(math,textord,"⋮","\\varvdots");defineSymbol(math,accent,"ˊ","\\acute");defineSymbol(math,accent,"`","\\grave");defineSymbol(math,accent,"¨","\\ddot");defineSymbol(math,accent,"…","\\dddot");defineSymbol(math,accent,"….","\\ddddot");defineSymbol(math,accent,"~","\\tilde");defineSymbol(math,accent,"‾","\\bar");defineSymbol(math,accent,"˘","\\breve");defineSymbol(math,accent,"ˇ","\\check");defineSymbol(math,accent,"^","\\hat");defineSymbol(math,accent,"→","\\vec");defineSymbol(math,accent,"˙","\\dot");defineSymbol(math,accent,"˚","\\mathring");defineSymbol(math,mathord,"ı","\\imath",true);defineSymbol(math,mathord,"ȷ","\\jmath",true);defineSymbol(math,textord,"ı","ı");defineSymbol(math,textord,"ȷ","ȷ");defineSymbol(text,textord,"ı","\\i",true);defineSymbol(text,textord,"ȷ","\\j",true);defineSymbol(text,textord,"ß","\\ss",true);defineSymbol(text,textord,"æ","\\ae",true);defineSymbol(text,textord,"œ","\\oe",true);defineSymbol(text,textord,"ø","\\o",true);defineSymbol(math,mathord,"ø","\\o",true);defineSymbol(text,textord,"Æ","\\AE",true);defineSymbol(text,textord,"Œ","\\OE",true);defineSymbol(text,textord,"Ø","\\O",true);defineSymbol(math,mathord,"Ø","\\O",true);defineSymbol(text,accent,"ˊ","\\'");defineSymbol(text,accent,"ˋ","\\`");defineSymbol(text,accent,"ˆ","\\^");defineSymbol(text,accent,"˜","\\~");defineSymbol(text,accent,"ˉ","\\=");defineSymbol(text,accent,"˘","\\u");defineSymbol(text,accent,"˙","\\.");defineSymbol(text,accent,"¸","\\c");defineSymbol(text,accent,"˚","\\r");defineSymbol(text,accent,"ˇ","\\v");defineSymbol(text,accent,"¨",'\\"');defineSymbol(text,accent,"˝","\\H");defineSymbol(math,accent,"ˊ","\\'");defineSymbol(math,accent,"ˋ","\\`");defineSymbol(math,accent,"ˆ","\\^");defineSymbol(math,accent,"˜","\\~");defineSymbol(math,accent,"ˉ","\\=");defineSymbol(math,accent,"˘","\\u");defineSymbol(math,accent,"˙","\\.");defineSymbol(math,accent,"¸","\\c");defineSymbol(math,accent,"˚","\\r");defineSymbol(math,accent,"ˇ","\\v");defineSymbol(math,accent,"¨",'\\"');defineSymbol(math,accent,"˝","\\H");const ligatures={"--":true,"---":true,"``":true,"''":true};defineSymbol(text,textord,"–","--",true);defineSymbol(text,textord,"–","\\textendash");defineSymbol(text,textord,"—","---",true);defineSymbol(text,textord,"—","\\textemdash");defineSymbol(text,textord,"‘","`",true);defineSymbol(text,textord,"‘","\\textquoteleft");defineSymbol(text,textord,"’","'",true);defineSymbol(text,textord,"’","\\textquoteright");defineSymbol(text,textord,"“","``",true);defineSymbol(text,textord,"“","\\textquotedblleft");defineSymbol(text,textord,"”","''",true);defineSymbol(text,textord,"”","\\textquotedblright");defineSymbol(math,textord,"°","\\degree",true);defineSymbol(text,textord,"°","\\degree");defineSymbol(text,textord,"°","\\textdegree",true);defineSymbol(math,textord,"£","\\pounds");defineSymbol(math,textord,"£","\\mathsterling",true);defineSymbol(text,textord,"£","\\pounds");defineSymbol(text,textord,"£","\\textsterling",true);defineSymbol(math,textord,"✠","\\maltese");defineSymbol(text,textord,"✠","\\maltese");defineSymbol(math,textord,"€","\\euro",true);defineSymbol(text,textord,"€","\\euro",true);defineSymbol(text,textord,"€","\\texteuro");defineSymbol(math,textord,"©","\\copyright",true);defineSymbol(text,textord,"©","\\textcopyright");defineSymbol(math,textord,"𝛤","\\varGamma");defineSymbol(math,textord,"𝛥","\\varDelta");defineSymbol(math,textord,"𝛩","\\varTheta");defineSymbol(math,textord,"𝛬","\\varLambda");defineSymbol(math,textord,"𝛯","\\varXi");defineSymbol(math,textord,"𝛱","\\varPi");defineSymbol(math,textord,"𝛴","\\varSigma");defineSymbol(math,textord,"𝛶","\\varUpsilon");defineSymbol(math,textord,"𝛷","\\varPhi");defineSymbol(math,textord,"𝛹","\\varPsi");defineSymbol(math,textord,"𝛺","\\varOmega");defineSymbol(text,textord,"𝛤","\\varGamma");defineSymbol(text,textord,"𝛥","\\varDelta");defineSymbol(text,textord,"𝛩","\\varTheta");defineSymbol(text,textord,"𝛬","\\varLambda");defineSymbol(text,textord,"𝛯","\\varXi");defineSymbol(text,textord,"𝛱","\\varPi");defineSymbol(text,textord,"𝛴","\\varSigma");defineSymbol(text,textord,"𝛶","\\varUpsilon");defineSymbol(text,textord,"𝛷","\\varPhi");defineSymbol(text,textord,"𝛹","\\varPsi");defineSymbol(text,textord,"𝛺","\\varOmega");const mathTextSymbols='0123456789/@."';for(let e=0;e<mathTextSymbols.length;e++){const t=mathTextSymbols.charAt(e);defineSymbol(math,textord,t,t)}const textSymbols='0123456789!@*()-=+";:?/.,';for(let e=0;e<textSymbols.length;e++){const t=textSymbols.charAt(e);defineSymbol(text,textord,t,t)}const letters="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";for(let e=0;e<letters.length;e++){const t=letters.charAt(e);defineSymbol(math,mathord,t,t);defineSymbol(text,textord,t,t)}const narrow="ÇÐÞçþℂℍℕℙℚℝℤℎℏℊℋℌℐℑℒℓ℘ℛℜℬℰℱℳℭℨ";for(let e=0;e<narrow.length;e++){const t=narrow.charAt(e);defineSymbol(math,mathord,t,t);defineSymbol(text,textord,t,t)}let wideChar="";for(let e=0;e<letters.length;e++){wideChar=String.fromCharCode(55349,56320+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,56372+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,56424+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,56580+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,56736+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,56788+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,56840+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,56944+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,56632+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);const t=letters.charAt(e);wideChar=String.fromCharCode(55349,56476+e);defineSymbol(math,mathord,t,wideChar);defineSymbol(text,textord,t,wideChar)}for(let e=0;e<10;e++){wideChar=String.fromCharCode(55349,57294+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,57314+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,57324+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar);wideChar=String.fromCharCode(55349,57334+e);defineSymbol(math,mathord,wideChar,wideChar);defineSymbol(text,textord,wideChar,wideChar)}function setLineBreaks(e,t,r,n){if(n===undefined&&t!=="none"){const n=e.length-1;for(let o=n;o>=0;o--){const n=e[o];if(n.type==="mstyle"&&n.attributes.mathcolor){const a=n.attributes.mathcolor;const i=setLineBreaks(n.children,t,r,a);if(!(i.type&&i.type!=="mtable")){e.splice(o,1,...i.children)}}}}const o=n?"mstyle":"mrow";const a=[];let i=[];let s=[];let l=0;let m=false;for(let r=0;r<e.length;r++){const d=e[r];if(d.type&&d.type==="mstyle"&&d.attributes.mathcolor){if(s.length>0){i.push(new mathMLTree.MathNode(o,s))}i.push(d);s=[];continue}if(d.attributes&&d.attributes.linebreak&&d.attributes.linebreak==="newline"){if(s.length>0){const e=new mathMLTree.MathNode(o,s);if(n){e.setAttribute("mathcolor",n)}i.push(new mathMLTree.MathNode(o,s))}i.push(d);s=[];const e=new mathMLTree.MathNode("mtd",i);a.push(new mathMLTree.MathNode("mtr",[e]));i=[];continue}s.push(d);if(d.type&&d.type==="mo"&&t==="="){if(d.children.length===1&&d.children[0].text==="="){l+=1;if(l>1){s.pop();const e=new mathMLTree.MathNode(o,s);if(n){e.setAttribute("mathcolor",n)}i.push(e);s=[d]}}}else if(d.type&&d.type==="mo"&&t==="tex"){if(m&&!d.attributes.form){const t=r<e.length-1?e[r+1]:null;let a=true;if(!(t&&t.type==="mtext"&&t.attributes.linebreak&&t.attributes.linebreak==="nobreak")){for(let t=r+1;t<e.length;t++){const n=e[t];if(n.type&&n.type==="mspace"&&!(n.attributes.linebreak&&n.attributes.linebreak==="newline")){s.push(n);r+=1;if(n.attributes&&n.attributes.linebreak&&n.attributes.linebreak==="nobreak"){a=false}}else{break}}}if(a){const e=new mathMLTree.MathNode(o,s);if(n){e.setAttribute("mathcolor",n)}i.push(e);s=[]}m=false}const t=d.attributes.form&&d.attributes.form==="prefix";m=!(d.attributes.separator||t)}else{m=true}}if(s.length>0){const e=new mathMLTree.MathNode(o,s);if(n){e.setAttribute("mathcolor",n)}i.push(e)}if(a.length>0){const e=new mathMLTree.MathNode("mtd",i);const t=new mathMLTree.MathNode("mtr",[e]);a.push(t);const n=new mathMLTree.MathNode("mtable",a);if(!r){n.setAttribute("columnalign","left");n.setAttribute("rowspacing","0em")}return n}return mathMLTree.newDocumentFragment(i)}const makeText=function(e,t,r){if(symbols[t][e]&&symbols[t][e].replace&&e.charCodeAt(0)!==55349&&!(Object.prototype.hasOwnProperty.call(ligatures,e)&&r&&(r.fontFamily&&r.fontFamily.slice(4,6)==="tt"||r.font&&r.font.slice(4,6)==="tt"))){e=symbols[t][e].replace}return new mathMLTree.TextNode(e)};const consolidateText=e=>{if(e.type!=="mrow"){return e}if(e.children.length===0){return e}if(!e.children[0].attributes||e.children[0].type!=="mtext"){return e}const t=e.children[0].attributes.mathvariant||"";const r=new mathMLTree.MathNode("mtext",[new mathMLTree.TextNode(e.children[0].children[0].text)]);for(let n=1;n<e.children.length;n++){const o=e.children[n].attributes.mathvariant||"";if(e.children[n].type==="mrow"){const o=e.children[n];for(let n=0;n<o.children.length;n++){const a=o.children[n].attributes.mathvariant||"";if(a!==t||o.children[n].type!=="mtext"){return e}else{r.children[0].text+=o.children[n].children[0].text}}}else if(o!==t||e.children[n].type!=="mtext"){return e}else{r.children[0].text+=e.children[n].children[0].text}}if(r.children[0].text.charAt(0)===" "){r.children[0].text=" "+r.children[0].text.slice(1)}const n=r.children[0].text.length;if(n>0&&r.children[0].text.charAt(n-1)===" "){r.children[0].text=r.children[0].text.slice(0,-1)+" "}return r};const makeRow=function(e){if(e.length===1){return e[0]}else{return new mathMLTree.MathNode("mrow",e)}};const isRel=e=>e.type==="atom"&&e.family==="rel"||e.type==="mclass"&&e.mclass==="mrel";const buildExpression=function(e,t,r){if(e.length===1){const n=buildGroup$1(e[0],t);if(r&&n instanceof MathNode&&n.type==="mo"){n.setAttribute("lspace","0em");n.setAttribute("rspace","0em")}return[n]}const n=[];for(let r=0;r<e.length;r++){const o=buildGroup$1(e[r],t);if(r<e.length-1&&isRel(e[r])&&isRel(e[r+1])){o.setAttribute("rspace","0em")}if(r>0&&isRel(e[r])&&isRel(e[r-1])){o.setAttribute("lspace","0em")}n.push(o)}return n};const buildExpressionRow=function(e,t,r){return makeRow(buildExpression(e,t,r))};const buildGroup$1=function(e,t){if(!e){return new mathMLTree.MathNode("mrow")}if(_mathmlGroupBuilders[e.type]){const r=_mathmlGroupBuilders[e.type](e,t);return r}else{throw new ParseError("Got group of unknown type: '"+e.type+"'")}};const glue$1=e=>new mathMLTree.MathNode("mtd",[],[],{padding:"0",width:"50%"});const taggedExpression=(e,t,r,n)=>{t=buildExpressionRow(t[0].body,r);t=consolidateText(t);t.classes.push("tml-tag");e=new mathMLTree.MathNode("mtd",[e]);const o=[glue$1(),e,glue$1()];if(n){o[0].children.push(t);o[0].style.textAlign="-webkit-left"}else{o[2].children.push(t);o[2].style.textAlign="-webkit-right"}const a=new mathMLTree.MathNode("mtr",o,["tml-tageqn"]);const i=new mathMLTree.MathNode("mtable",[a]);i.style.width="100%";i.setAttribute("displaystyle","true");return i};function buildMathML(e,t,r,n){let o=null;if(e.length===1&&e[0].type==="tag"){o=e[0].tag;e=e[0].body}const a=buildExpression(e,r);const i=n.displayMode||n.annotate?"none":n.wrap;const s=a.length===0?null:a[0];let l=a.length===1&&o===null&&s instanceof MathNode&&!(s.type==="mstyle"&&s.attributes.mathcolor)?a[0]:setLineBreaks(a,i,n.displayMode);if(o){l=taggedExpression(l,o,r,n.leqno)}if(n.annotate){const e=new mathMLTree.MathNode("annotation",[new mathMLTree.TextNode(t)]);e.setAttribute("encoding","application/x-tex");l=new mathMLTree.MathNode("semantics",[l,e])}if(i!=="none"&&l.children.length>1){const e=[];for(let t=0;t<l.children.length;t++){const r=new mathMLTree.MathNode("math",[l.children[t]]);if(n.xml){r.setAttribute("xmlns","http://www.w3.org/1998/Math/MathML")}e.push(r)}return mathMLTree.newDocumentFragment(e)}const m=new mathMLTree.MathNode("math",[l]);if(n.xml){m.setAttribute("xmlns","http://www.w3.org/1998/Math/MathML")}if(n.displayMode){m.setAttribute("display","block")}return m}const mathmlBuilder$a=(e,t)=>{const r=e.isStretchy?stretchy.mathMLnode(e.label):new mathMLTree.MathNode("mo",[makeText(e.label,e.mode)]);if(e.label==="\\vec"){r.style.transform="scale(0.75) translate(10%, 30%)"}else{r.style.mathStyle="normal";r.style.mathDepth="0"}if(!e.isStretchy){r.setAttribute("stretchy","false")}const n=new mathMLTree.MathNode(e.label==="\\c"?"munder":"mover",[buildGroup$1(e.base,t),r]);return n};const NON_STRETCHY_ACCENT_REGEX=new RegExp(["\\acute","\\grave","\\ddot","\\dddot","\\ddddot","\\tilde","\\bar","\\breve","\\check","\\hat","\\vec","\\dot","\\mathring"].map((e=>`\\${e}`)).join("|"));defineFunction({type:"accent",names:["\\acute","\\grave","\\ddot","\\dddot","\\ddddot","\\tilde","\\bar","\\breve","\\check","\\hat","\\vec","\\dot","\\mathring","\\overparen","\\widecheck","\\widehat","\\wideparen","\\widetilde","\\overrightarrow","\\overleftarrow","\\Overrightarrow","\\overleftrightarrow","\\overgroup","\\overleftharpoon","\\overrightharpoon"],props:{numArgs:1},handler:(e,t)=>{const r=normalizeArgument(t[0]);const n=!NON_STRETCHY_ACCENT_REGEX.test(e.funcName);return{type:"accent",mode:e.parser.mode,label:e.funcName,isStretchy:n,base:r}},mathmlBuilder:mathmlBuilder$a});defineFunction({type:"accent",names:["\\'","\\`","\\^","\\~","\\=","\\c","\\u","\\.",'\\"',"\\r","\\H","\\v"],props:{numArgs:1,allowedInText:true,allowedInMath:true,argTypes:["primitive"]},handler:(e,t)=>{const r=normalizeArgument(t[0]);const n=e.parser.mode;if(n==="math"&&e.parser.settings.strict){console.log(`Temml parse error: Command ${e.funcName} is invalid in math mode.`)}return{type:"accent",mode:n,label:e.funcName,isStretchy:false,isShifty:true,base:r}},mathmlBuilder:mathmlBuilder$a});defineFunction({type:"accentUnder",names:["\\underleftarrow","\\underrightarrow","\\underleftrightarrow","\\undergroup","\\underparen","\\utilde"],props:{numArgs:1},handler:({parser:e,funcName:t},r)=>{const n=r[0];return{type:"accentUnder",mode:e.mode,label:t,base:n}},mathmlBuilder:(e,t)=>{const r=stretchy.mathMLnode(e.label);r.style["math-depth"]=0;const n=new mathMLTree.MathNode("munder",[buildGroup$1(e.base,t),r]);return n}});const ptPerUnit={pt:800/803,pc:12*800/803,dd:1238/1157*800/803,cc:14856/1157*800/803,nd:685/642*800/803,nc:1370/107*800/803,sp:1/65536*800/803,mm:25.4/72,cm:2.54/72,in:1/72,px:96/72};const validUnits=["em","ex","mu","pt","mm","cm","in","px","bp","pc","dd","cc","nd","nc","sp"];const validUnit=function(e){if(typeof e!=="string"){e=e.unit}return validUnits.indexOf(e)>-1};const emScale=e=>{const t=Math.max(e-1,0);return[1,.7,.5][t]};const calculateSize=function(e,t){let r=e.number;if(t.maxSize[0]<0&&r>0){return{number:0,unit:"em"}}const n=e.unit;switch(n){case"mm":case"cm":case"in":case"px":{const e=r*ptPerUnit[n];if(e>t.maxSize[1]){return{number:t.maxSize[1],unit:"pt"}}return{number:r,unit:n}}case"em":case"ex":{if(n==="ex"){r*=.431}r=Math.min(r/emScale(t.level),t.maxSize[0]);return{number:utils.round(r),unit:"em"}}case"bp":{if(r>t.maxSize[1]){r=t.maxSize[1]}return{number:r,unit:"pt"}}case"pt":case"pc":case"dd":case"cc":case"nd":case"nc":case"sp":{r=Math.min(r*ptPerUnit[n],t.maxSize[1]);return{number:utils.round(r),unit:"pt"}}case"mu":{r=Math.min(r/18,t.maxSize[0]);return{number:utils.round(r),unit:"em"}}default:throw new ParseError("Invalid unit: '"+n+"'")}};const padding$2=e=>{const t=new mathMLTree.MathNode("mspace");t.setAttribute("width",e+"em");return t};const paddedNode=(e,t=.3,r=0)=>{if(e==null&&r===0){return padding$2(t)}const n=e?[e]:[];if(t!==0){n.unshift(padding$2(t))}if(r>0){n.push(padding$2(r))}return new mathMLTree.MathNode("mrow",n)};const labelSize=(e,t)=>(e/emScale(t)).toFixed(4);const munderoverNode=(e,t,r,n)=>{const o=stretchy.mathMLnode(e);const a=e.slice(1,3)==="eq";const i=e.charAt(1)==="x"?"1.75":e.slice(2,4)==="cd"?"3.0":a?"1.0":"2.0";o.setAttribute("minsize",String(i)+"em");o.setAttribute("lspace","0");o.setAttribute("rspace",a?"0.5em":"0");const s=n.withLevel(n.level<2?2:3);const l=labelSize(i,s.level);const m=labelSize(a?0:.3,s.level);const d=labelSize(a?0:.3,s.level);const c=t&&t.body&&(t.body.body||t.body.length>0)?paddedNode(buildGroup$1(t,s),m,d):paddedNode(null,l,0);const u=r&&r.body&&(r.body.body||r.body.length>0)?paddedNode(buildGroup$1(r,s),m,d):paddedNode(null,l,0);const h=new mathMLTree.MathNode("munderover",[o,u,c]);if(i==="3.0"){h.style.height="1em"}return h};defineFunction({type:"xArrow",names:["\\xleftarrow","\\xrightarrow","\\xLeftarrow","\\xRightarrow","\\xleftrightarrow","\\xLeftrightarrow","\\xhookleftarrow","\\xhookrightarrow","\\xmapsto","\\xrightharpoondown","\\xrightharpoonup","\\xleftharpoondown","\\xleftharpoonup","\\xlongequal","\\xtwoheadrightarrow","\\xtwoheadleftarrow","\\yields","\\yieldsLeft","\\mesomerism","\\longrightharpoonup","\\longleftharpoondown","\\\\cdrightarrow","\\\\cdleftarrow","\\\\cdlongequal"],props:{numArgs:1,numOptionalArgs:1},handler({parser:e,funcName:t},r,n){return{type:"xArrow",mode:e.mode,name:t,body:r[0],below:n[0]}},mathmlBuilder(e,t){const r=munderoverNode(e.name,e.body,e.below,t);const n=[r];n.unshift(padding$2(.2778));n.push(padding$2(.2778));return new mathMLTree.MathNode("mrow",n)}});const arrowComponent={"\\xtofrom":["\\xrightarrow","\\xleftarrow"],"\\xleftrightharpoons":["\\xleftharpoonup","\\xrightharpoondown"],"\\xrightleftharpoons":["\\xrightharpoonup","\\xleftharpoondown"],"\\yieldsLeftRight":["\\yields","\\yieldsLeft"],"\\equilibrium":["\\longrightharpoonup","\\longleftharpoondown"],"\\equilibriumRight":["\\longrightharpoonup","\\eqleftharpoondown"],"\\equilibriumLeft":["\\eqrightharpoonup","\\longleftharpoondown"]};defineFunction({type:"stackedArrow",names:["\\xtofrom","\\xleftrightharpoons","\\xrightleftharpoons","\\yieldsLeftRight","\\equilibrium","\\equilibriumRight","\\equilibriumLeft"],props:{numArgs:1,numOptionalArgs:1},handler({parser:e,funcName:t},r,n){const o=r[0]?{type:"hphantom",mode:e.mode,body:r[0]}:null;const a=n[0]?{type:"hphantom",mode:e.mode,body:n[0]}:null;return{type:"stackedArrow",mode:e.mode,name:t,body:r[0],upperArrowBelow:a,lowerArrowBody:o,below:n[0]}},mathmlBuilder(e,t){const r=arrowComponent[e.name][0];const n=arrowComponent[e.name][1];const o=munderoverNode(r,e.body,e.upperArrowBelow,t);const a=munderoverNode(n,e.lowerArrowBody,e.below,t);let i;const s=new mathMLTree.MathNode("mpadded",[o]);s.setAttribute("voffset","0.3em");s.setAttribute("height","+0.3em");s.setAttribute("depth","-0.3em");if(e.name==="\\equilibriumLeft"){const e=new mathMLTree.MathNode("mpadded",[a]);e.setAttribute("width","0.5em");i=new mathMLTree.MathNode("mpadded",[padding$2(.2778),e,s,padding$2(.2778)])}else{s.setAttribute("width",e.name==="\\equilibriumRight"?"0.5em":"0");i=new mathMLTree.MathNode("mpadded",[padding$2(.2778),s,a,padding$2(.2778)])}i.setAttribute("voffset","-0.18em");i.setAttribute("height","-0.18em");i.setAttribute("depth","+0.18em");return i}});function assertNodeType(e,t){if(!e||e.type!==t){throw new Error(`Expected node of type ${t}, but got `+(e?`node of type ${e.type}`:String(e)))}return e}function assertSymbolNodeType(e){const t=checkSymbolNodeType(e);if(!t){throw new Error(`Expected node of symbol group type, but got `+(e?`node of type ${e.type}`:String(e)))}return t}function checkSymbolNodeType(e){if(e&&(e.type==="atom"||Object.prototype.hasOwnProperty.call(NON_ATOMS,e.type))){return e}return null}const cdArrowFunctionName={">":"\\\\cdrightarrow","<":"\\\\cdleftarrow","=":"\\\\cdlongequal",A:"\\uparrow",V:"\\downarrow","|":"\\Vert",".":"no arrow"};const newCell=()=>({type:"styling",body:[],mode:"math",scriptLevel:"display"});const isStartOfArrow=e=>e.type==="textord"&&e.text==="@";const isLabelEnd=(e,t)=>(e.type==="mathord"||e.type==="atom")&&e.text===t;function cdArrow(e,t,r){const n=cdArrowFunctionName[e];switch(n){case"\\\\cdrightarrow":case"\\\\cdleftarrow":return r.callFunction(n,[t[0]],[t[1]]);case"\\uparrow":case"\\downarrow":{const e=r.callFunction("\\\\cdleft",[t[0]],[]);const o={type:"atom",text:n,mode:"math",family:"rel"};const a=r.callFunction("\\Big",[o],[]);const i=r.callFunction("\\\\cdright",[t[1]],[]);const s={type:"ordgroup",mode:"math",body:[e,a,i]};return r.callFunction("\\\\cdparent",[s],[])}case"\\\\cdlongequal":return r.callFunction("\\\\cdlongequal",[],[]);case"\\Vert":{const e={type:"textord",text:"\\Vert",mode:"math"};return r.callFunction("\\Big",[e],[])}default:return{type:"textord",text:" ",mode:"math"}}}function parseCD(e){const t=[];e.gullet.beginGroup();e.gullet.macros.set("\\cr","\\\\\\relax");e.gullet.beginGroup();while(true){t.push(e.parseExpression(false,"\\\\"));e.gullet.endGroup();e.gullet.beginGroup();const r=e.fetch().text;if(r==="&"||r==="\\\\"){e.consume()}else if(r==="\\end"){if(t[t.length-1].length===0){t.pop()}break}else{throw new ParseError("Expected \\\\ or \\cr or \\end",e.nextToken)}}let r=[];const n=[r];for(let o=0;o<t.length;o++){const a=t[o];let i=newCell();for(let t=0;t<a.length;t++){if(!isStartOfArrow(a[t])){i.body.push(a[t])}else{r.push(i);t+=1;const n=assertSymbolNodeType(a[t]).text;const o=new Array(2);o[0]={type:"ordgroup",mode:"math",body:[]};o[1]={type:"ordgroup",mode:"math",body:[]};if("=|.".indexOf(n)>-1);else if("<>AV".indexOf(n)>-1){for(let e=0;e<2;e++){let r=true;for(let i=t+1;i<a.length;i++){if(isLabelEnd(a[i],n)){r=false;t=i;break}if(isStartOfArrow(a[i])){throw new ParseError("Missing a "+n+" character to complete a CD arrow.",a[i])}o[e].body.push(a[i])}if(r){throw new ParseError("Missing a "+n+" character to complete a CD arrow.",a[t])}}}else{throw new ParseError(`Expected one of "<>AV=|." after @.`)}const s=cdArrow(n,o,e);r.push(s);i=newCell()}}if(o%2===0){r.push(i)}else{r.shift()}r=[];n.push(r)}n.pop();e.gullet.endGroup();e.gullet.endGroup();return{type:"array",mode:"math",body:n,envClasses:["jot","cd"],cols:[],hLinesBeforeRow:new Array(n.length+1).fill([])}}defineFunction({type:"cdlabel",names:["\\\\cdleft","\\\\cdright"],props:{numArgs:1},handler({parser:e,funcName:t},r){return{type:"cdlabel",mode:e.mode,side:t.slice(4),label:r[0]}},mathmlBuilder(e,t){let r=new mathMLTree.MathNode("mrow",[buildGroup$1(e.label,t)]);r=new mathMLTree.MathNode("mpadded",[r]);r.setAttribute("width","0");if(e.side==="left"){r.setAttribute("lspace","-1width")}r.setAttribute("voffset","0.7em");r=new mathMLTree.MathNode("mstyle",[r]);r.setAttribute("displaystyle","false");r.setAttribute("scriptlevel","1");return r}});defineFunction({type:"cdlabelparent",names:["\\\\cdparent"],props:{numArgs:1},handler({parser:e},t){return{type:"cdlabelparent",mode:e.mode,fragment:t[0]}},mathmlBuilder(e,t){return new mathMLTree.MathNode("mrow",[buildGroup$1(e.fragment,t)])}});defineFunction({type:"textord",names:["\\@char"],props:{numArgs:1,allowedInText:true},handler({parser:e,token:t},r){const n=assertNodeType(r[0],"ordgroup");const o=n.body;let a="";for(let e=0;e<o.length;e++){const t=assertNodeType(o[e],"textord");a+=t.text}const i=parseInt(a);if(isNaN(i)){throw new ParseError(`\\@char has non-numeric argument ${a}`,t)}return{type:"textord",mode:e.mode,text:String.fromCodePoint(i)}}});const htmlRegEx=/^(#[a-f0-9]{3}|#?[a-f0-9]{6})$/i;const htmlOrNameRegEx=/^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i;const RGBregEx=/^ *\d{1,3} *(?:, *\d{1,3} *){2}$/;const rgbRegEx=/^ *[10](?:\.\d*)? *(?:, *[10](?:\.\d*)? *){2}$/;const xcolorHtmlRegEx=/^[a-f0-9]{6}$/i;const toHex=e=>{let t=e.toString(16);if(t.length===1){t="0"+t}return t};const xcolors=JSON.parse(`{\n  "Apricot": "#ffb484",\n  "Aquamarine": "#08b4bc",\n  "Bittersweet": "#c84c14",\n  "blue": "#0000FF",\n  "Blue": "#303494",\n  "BlueGreen": "#08b4bc",\n  "BlueViolet": "#503c94",\n  "BrickRed": "#b8341c",\n  "brown": "#BF8040",\n  "Brown": "#802404",\n  "BurntOrange": "#f8941c",\n  "CadetBlue": "#78749c",\n  "CarnationPink": "#f884b4",\n  "Cerulean": "#08a4e4",\n  "CornflowerBlue": "#40ace4",\n  "cyan": "#00FFFF",\n  "Cyan": "#08acec",\n  "Dandelion": "#ffbc44",\n  "darkgray": "#404040",\n  "DarkOrchid": "#a8548c",\n  "Emerald": "#08ac9c",\n  "ForestGreen": "#089c54",\n  "Fuchsia": "#90348c",\n  "Goldenrod": "#ffdc44",\n  "gray": "#808080",\n  "Gray": "#98949c",\n  "green": "#00FF00",\n  "Green": "#08a44c",\n  "GreenYellow": "#e0e474",\n  "JungleGreen": "#08ac9c",\n  "Lavender": "#f89cc4",\n  "lightgray": "#c0c0c0",\n  "lime": "#BFFF00",\n  "LimeGreen": "#90c43c",\n  "magenta": "#FF00FF",\n  "Magenta": "#f0048c",\n  "Mahogany": "#b0341c",\n  "Maroon": "#b03434",\n  "Melon": "#f89c7c",\n  "MidnightBlue": "#086494",\n  "Mulberry": "#b03c94",\n  "NavyBlue": "#086cbc",\n  "olive": "#7F7F00",\n  "OliveGreen": "#407c34",\n  "orange": "#FF8000",\n  "Orange": "#f8843c",\n  "OrangeRed": "#f0145c",\n  "Orchid": "#b074ac",\n  "Peach": "#f8945c",\n  "Periwinkle": "#8074bc",\n  "PineGreen": "#088c74",\n  "pink": "#ff7f7f",\n  "Plum": "#98248c",\n  "ProcessBlue": "#08b4ec",\n  "purple": "#BF0040",\n  "Purple": "#a0449c",\n  "RawSienna": "#983c04",\n  "red": "#ff0000",\n  "Red": "#f01c24",\n  "RedOrange": "#f86434",\n  "RedViolet": "#a0246c",\n  "Rhodamine": "#f0549c",\n  "Royallue": "#0874bc",\n  "RoyalPurple": "#683c9c",\n  "RubineRed": "#f0047c",\n  "Salmon": "#f8948c",\n  "SeaGreen": "#30bc9c",\n  "Sepia": "#701404",\n  "SkyBlue": "#48c4dc",\n  "SpringGreen": "#c8dc64",\n  "Tan": "#e09c74",\n  "teal": "#007F7F",\n  "TealBlue": "#08acb4",\n  "Thistle": "#d884b4",\n  "Turquoise": "#08b4cc",\n  "violet": "#800080",\n  "Violet": "#60449c",\n  "VioletRed": "#f054a4",\n  "WildStrawberry": "#f0246c",\n  "yellow": "#FFFF00",\n  "Yellow": "#fff404",\n  "YellowGreen": "#98cc6c",\n  "YellowOrange": "#ffa41c"\n}`);const colorFromSpec=(e,t)=>{let r="";if(e==="HTML"){if(!htmlRegEx.test(t)){throw new ParseError("Invalid HTML input.")}r=t}else if(e==="RGB"){if(!RGBregEx.test(t)){throw new ParseError("Invalid RGB input.")}t.split(",").map((e=>{r+=toHex(Number(e.trim()))}))}else{if(!rgbRegEx.test(t)){throw new ParseError("Invalid rbg input.")}t.split(",").map((e=>{const t=Number(e.trim());if(t>1){throw new ParseError("Color rgb input must be < 1.")}r+=toHex(t*255)}))}if(r.charAt(0)!=="#"){r="#"+r}return r};const validateColor=(e,t,r)=>{const n=`\\\\color@${e}`;const o=htmlOrNameRegEx.exec(e);if(!o){throw new ParseError("Invalid color: '"+e+"'",r)}if(xcolorHtmlRegEx.test(e)){return"#"+e}else if(e.charAt(0)==="#"){return e}else if(t.has(n)){e=t.get(n).tokens[0].text}else if(xcolors[e]){e=xcolors[e]}return e};const mathmlBuilder$9=(e,t)=>{const r=buildExpression(e.body,t.withColor(e.color));const n=wrapWithMstyle(r);n.setAttribute("mathcolor",e.color);return n};defineFunction({type:"color",names:["\\textcolor"],props:{numArgs:2,numOptionalArgs:1,allowedInText:true,argTypes:["raw","raw","original"]},handler({parser:e,token:t},r,n){const o=n[0]&&assertNodeType(n[0],"raw").string;let a="";if(o){const e=assertNodeType(r[0],"raw").string;a=colorFromSpec(o,e)}else{a=validateColor(assertNodeType(r[0],"raw").string,e.gullet.macros,t)}const i=r[1];return{type:"color",mode:e.mode,color:a,body:ordargument(i)}},mathmlBuilder:mathmlBuilder$9});defineFunction({type:"color",names:["\\color"],props:{numArgs:1,numOptionalArgs:1,allowedInText:true,argTypes:["raw","raw"]},handler({parser:e,token:t},r,n){const o=n[0]&&assertNodeType(n[0],"raw").string;let a="";if(o){const e=assertNodeType(r[0],"raw").string;a=colorFromSpec(o,e)}else{a=validateColor(assertNodeType(r[0],"raw").string,e.gullet.macros,t)}e.gullet.macros.set("\\current@color",a);const i=e.parseExpression(true,"\\color");return{type:"color",mode:e.mode,color:a,body:i}},mathmlBuilder:mathmlBuilder$9});defineFunction({type:"color",names:["\\definecolor"],props:{numArgs:3,allowedInText:true,argTypes:["raw","raw","raw"]},handler({parser:e,funcName:t,token:r},n){const o=assertNodeType(n[0],"raw").string;if(!/^[A-Za-z]+$/.test(o)){throw new ParseError("Color name must be latin letters.",r)}const a=assertNodeType(n[1],"raw").string;if(!["HTML","RGB","rgb"].includes(a)){throw new ParseError("Color model must be HTML, RGB, or rgb.",r)}const i=assertNodeType(n[2],"raw").string;const s=colorFromSpec(a,i);e.gullet.macros.set(`\\\\color@${o}`,{tokens:[{text:s}],numArgs:0});return{type:"internal",mode:e.mode}}});defineFunction({type:"cr",names:["\\\\"],props:{numArgs:0,numOptionalArgs:0,allowedInText:true},handler({parser:e},t,r){const n=e.gullet.future().text==="["?e.parseSizeGroup(true):null;const o=!e.settings.displayMode;return{type:"cr",mode:e.mode,newLine:o,size:n&&assertNodeType(n,"size").value}},mathmlBuilder(e,t){const r=new mathMLTree.MathNode("mo");if(e.newLine){r.setAttribute("linebreak","newline");if(e.size){const n=calculateSize(e.size,t);r.setAttribute("height",n.number+n.unit)}}return r}});const globalMap={"\\global":"\\global","\\long":"\\\\globallong","\\\\globallong":"\\\\globallong","\\def":"\\gdef","\\gdef":"\\gdef","\\edef":"\\xdef","\\xdef":"\\xdef","\\let":"\\\\globallet","\\futurelet":"\\\\globalfuture"};const checkControlSequence=e=>{const t=e.text;if(/^(?:[\\{}$&#^_]|EOF)$/.test(t)){throw new ParseError("Expected a control sequence",e)}return t};const getRHS=e=>{let t=e.gullet.popToken();if(t.text==="="){t=e.gullet.popToken();if(t.text===" "){t=e.gullet.popToken()}}return t};const letCommand=(e,t,r,n)=>{let o=e.gullet.macros.get(r.text);if(o==null){r.noexpand=true;o={tokens:[r],numArgs:0,unexpandable:!e.gullet.isExpandable(r.text)}}e.gullet.macros.set(t,o,n)};defineFunction({type:"internal",names:["\\global","\\long","\\\\globallong"],props:{numArgs:0,allowedInText:true},handler({parser:e,funcName:t}){e.consumeSpaces();const r=e.fetch();if(globalMap[r.text]){if(t==="\\global"||t==="\\\\globallong"){r.text=globalMap[r.text]}return assertNodeType(e.parseFunction(),"internal")}throw new ParseError(`Invalid token after macro prefix`,r)}});defineFunction({type:"internal",names:["\\def","\\gdef","\\edef","\\xdef"],props:{numArgs:0,allowedInText:true,primitive:true},handler({parser:e,funcName:t}){let r=e.gullet.popToken();const n=r.text;if(/^(?:[\\{}$&#^_]|EOF)$/.test(n)){throw new ParseError("Expected a control sequence",r)}let o=0;let a;const i=[[]];while(e.gullet.future().text!=="{"){r=e.gullet.popToken();if(r.text==="#"){if(e.gullet.future().text==="{"){a=e.gullet.future();i[o].push("{");break}r=e.gullet.popToken();if(!/^[1-9]$/.test(r.text)){throw new ParseError(`Invalid argument number "${r.text}"`)}if(parseInt(r.text)!==o+1){throw new ParseError(`Argument number "${r.text}" out of order`)}o++;i.push([])}else if(r.text==="EOF"){throw new ParseError("Expected a macro definition")}else{i[o].push(r.text)}}let{tokens:s}=e.gullet.consumeArg();if(a){s.unshift(a)}if(t==="\\edef"||t==="\\xdef"){s=e.gullet.expandTokens(s);s.reverse()}e.gullet.macros.set(n,{tokens:s,numArgs:o,delimiters:i},t===globalMap[t]);return{type:"internal",mode:e.mode}}});defineFunction({type:"internal",names:["\\let","\\\\globallet"],props:{numArgs:0,allowedInText:true,primitive:true},handler({parser:e,funcName:t}){const r=checkControlSequence(e.gullet.popToken());e.gullet.consumeSpaces();const n=getRHS(e);letCommand(e,r,n,t==="\\\\globallet");return{type:"internal",mode:e.mode}}});defineFunction({type:"internal",names:["\\futurelet","\\\\globalfuture"],props:{numArgs:0,allowedInText:true,primitive:true},handler({parser:e,funcName:t}){const r=checkControlSequence(e.gullet.popToken());const n=e.gullet.popToken();const o=e.gullet.popToken();letCommand(e,r,o,t==="\\\\globalfuture");e.gullet.pushToken(o);e.gullet.pushToken(n);return{type:"internal",mode:e.mode}}});defineFunction({type:"internal",names:["\\newcommand","\\renewcommand","\\providecommand"],props:{numArgs:0,allowedInText:true,primitive:true},handler({parser:e,funcName:t}){let r="";const n=e.gullet.popToken();if(n.text==="{"){r=checkControlSequence(e.gullet.popToken());e.gullet.popToken()}else{r=checkControlSequence(n)}const o=e.gullet.isDefined(r);if(o&&t==="\\newcommand"){throw new ParseError(`\\newcommand{${r}} attempting to redefine ${r}; use \\renewcommand`)}if(!o&&t==="\\renewcommand"){throw new ParseError(`\\renewcommand{${r}} when command ${r} does not yet exist; use \\newcommand`)}let a=0;if(e.gullet.future().text==="["){let t=e.gullet.popToken();t=e.gullet.popToken();if(!/^[0-9]$/.test(t.text)){throw new ParseError(`Invalid number of arguments: "${t.text}"`)}a=parseInt(t.text);t=e.gullet.popToken();if(t.text!=="]"){throw new ParseError(`Invalid argument "${t.text}"`)}}const{tokens:i}=e.gullet.consumeArg();e.gullet.macros.set(r,{tokens:i,numArgs:a},!e.settings.strict);return{type:"internal",mode:e.mode}}});const delimiterSizes={"\\bigl":{mclass:"mopen",size:1},"\\Bigl":{mclass:"mopen",size:2},"\\biggl":{mclass:"mopen",size:3},"\\Biggl":{mclass:"mopen",size:4},"\\bigr":{mclass:"mclose",size:1},"\\Bigr":{mclass:"mclose",size:2},"\\biggr":{mclass:"mclose",size:3},"\\Biggr":{mclass:"mclose",size:4},"\\bigm":{mclass:"mrel",size:1},"\\Bigm":{mclass:"mrel",size:2},"\\biggm":{mclass:"mrel",size:3},"\\Biggm":{mclass:"mrel",size:4},"\\big":{mclass:"mord",size:1},"\\Big":{mclass:"mord",size:2},"\\bigg":{mclass:"mord",size:3},"\\Bigg":{mclass:"mord",size:4}};const delimiters=["(","\\lparen",")","\\rparen","[","\\lbrack","]","\\rbrack","\\{","\\lbrace","\\}","\\rbrace","\\lfloor","\\rfloor","⌊","⌋","\\lceil","\\rceil","⌈","⌉","<",">","\\langle","⟨","\\rangle","⟩","\\lt","\\gt","\\lvert","\\rvert","\\lVert","\\rVert","\\lgroup","\\rgroup","⟮","⟯","\\lmoustache","\\rmoustache","⎰","⎱","\\llbracket","\\rrbracket","⟦","⟦","\\lBrace","\\rBrace","⦃","⦄","/","\\backslash","|","\\vert","\\|","\\Vert","\\uparrow","\\Uparrow","\\downarrow","\\Downarrow","\\updownarrow","\\Updownarrow","."];const sizeToMaxHeight=[0,1.2,1.8,2.4,3];function checkDelimiter(e,t){if(e.type==="ordgroup"&&e.body.length===1&&e.body[0].text==="⁄"){e={type:"textord",text:"/",mode:"math"}}const r=checkSymbolNodeType(e);if(r&&delimiters.includes(r.text)){if(["<","\\lt"].includes(r.text)){r.text="⟨"}if([">","\\gt"].includes(r.text)){r.text="⟩"}if(r.text==="/"){r.text="∕"}if(r.text==="\\backslash"){r.text="∖"}return r}else if(r){throw new ParseError(`Invalid delimiter '${r.text}' after '${t.funcName}'`,e)}else{throw new ParseError(`Invalid delimiter type '${e.type}'`,e)}}defineFunction({type:"delimsizing",names:["\\bigl","\\Bigl","\\biggl","\\Biggl","\\bigr","\\Bigr","\\biggr","\\Biggr","\\bigm","\\Bigm","\\biggm","\\Biggm","\\big","\\Big","\\bigg","\\Bigg"],props:{numArgs:1,argTypes:["primitive"]},handler:(e,t)=>{const r=checkDelimiter(t[0],e);return{type:"delimsizing",mode:e.parser.mode,size:delimiterSizes[e.funcName].size,mclass:delimiterSizes[e.funcName].mclass,delim:r.text}},mathmlBuilder:e=>{const t=[];if(e.delim==="."){e.delim=""}t.push(makeText(e.delim,e.mode));const r=new mathMLTree.MathNode("mo",t);if(e.mclass==="mopen"||e.mclass==="mclose"){r.setAttribute("fence","true")}else{r.setAttribute("fence","false")}if(e.delim==="∖"||e.delim.indexOf("arrow")>-1){r.setAttribute("stretchy","true")}r.setAttribute("symmetric","true");r.setAttribute("minsize",sizeToMaxHeight[e.size]+"em");return r}});function assertParsed(e){if(!e.body){throw new Error("Bug: The leftright ParseNode wasn't fully parsed.")}}defineFunction({type:"leftright-right",names:["\\right"],props:{numArgs:1,argTypes:["primitive"]},handler:(e,t)=>{const r=e.parser.gullet.macros.get("\\current@color");if(r&&typeof r!=="string"){throw new ParseError("\\current@color set to non-string in \\right")}return{type:"leftright-right",mode:e.parser.mode,delim:checkDelimiter(t[0],e).text,color:r}}});defineFunction({type:"leftright",names:["\\left"],props:{numArgs:1,argTypes:["primitive"]},handler:(e,t)=>{const r=checkDelimiter(t[0],e);const n=e.parser;++n.leftrightDepth;const o=n.parseExpression(false);--n.leftrightDepth;n.expect("\\right",false);const a=assertNodeType(n.parseFunction(),"leftright-right");return{type:"leftright",mode:n.mode,body:o,left:r.text,right:a.delim,rightColor:a.color}},mathmlBuilder:(e,t)=>{assertParsed(e);const r=buildExpression(e.body,t);if(e.left==="."){e.left=""}const n=new mathMLTree.MathNode("mo",[makeText(e.left,e.mode)]);n.setAttribute("fence","true");n.setAttribute("form","prefix");if(e.left==="∖"||e.left.indexOf("arrow")>-1){n.setAttribute("stretchy","true")}r.unshift(n);if(e.right==="."){e.right=""}const o=new mathMLTree.MathNode("mo",[makeText(e.right,e.mode)]);o.setAttribute("fence","true");o.setAttribute("form","postfix");if(e.right==="∖"||e.right.indexOf("arrow")>-1){o.setAttribute("stretchy","true")}if(e.rightColor){o.setAttribute("mathcolor",e.rightColor)}r.push(o);return makeRow(r)}});defineFunction({type:"middle",names:["\\middle"],props:{numArgs:1,argTypes:["primitive"]},handler:(e,t)=>{const r=checkDelimiter(t[0],e);if(!e.parser.leftrightDepth){throw new ParseError("\\middle without preceding \\left",r)}return{type:"middle",mode:e.parser.mode,delim:r.text}},mathmlBuilder:(e,t)=>{const r=makeText(e.delim,e.mode);const n=new mathMLTree.MathNode("mo",[r]);n.setAttribute("fence","true");if(e.delim.indexOf("arrow")>-1){n.setAttribute("stretchy","true")}n.setAttribute("form","prefix");n.setAttribute("lspace","0.05em");n.setAttribute("rspace","0.05em");return n}});const padding$1=e=>{const t=new mathMLTree.MathNode("mspace");t.setAttribute("width","3pt");return t};const mathmlBuilder$8=(e,t)=>{let r;if(e.label.indexOf("colorbox")>-1){r=new mathMLTree.MathNode("mpadded",[padding$1(),buildGroup$1(e.body,t),padding$1()])}else{r=new mathMLTree.MathNode("menclose",[buildGroup$1(e.body,t)])}switch(e.label){case"\\overline":r.setAttribute("notation","top");r.style.padding="0.1em 0 0 0";r.style.borderTop="0.065em solid";break;case"\\underline":r.setAttribute("notation","bottom");r.style.padding="0 0 0.1em 0";r.style.borderBottom="0.065em solid";break;case"\\cancel":r.setAttribute("notation","updiagonalstrike");r.classes.push("cancel");break;case"\\bcancel":r.setAttribute("notation","downdiagonalstrike");r.classes.push("bcancel");break;case"\\angl":r.setAttribute("notation","actuarial");r.style.padding="0.03889em 0.03889em 0 0.03889em";r.style.borderTop="0.049em solid";r.style.borderRight="0.049em solid";r.style.marginRight="0.03889em";break;case"\\sout":r.setAttribute("notation","horizontalstrike");r.style["text-decoration"]="line-through 0.08em solid";break;case"\\fbox":r.setAttribute("notation","box");r.style={padding:"3pt",border:"1px solid"};break;case"\\fcolorbox":case"\\colorbox":{const t={padding:"3pt 0 3pt 0"};if(e.label==="\\fcolorbox"){t.border="0.06em solid "+String(e.borderColor)}r.style=t;break}case"\\xcancel":r.setAttribute("notation","updiagonalstrike downdiagonalstrike");r.classes.push("xcancel");break}if(e.backgroundColor){r.setAttribute("mathbackground",e.backgroundColor)}return r};defineFunction({type:"enclose",names:["\\colorbox"],props:{numArgs:2,numOptionalArgs:1,allowedInText:true,argTypes:["raw","raw","text"]},handler({parser:e,funcName:t},r,n){const o=n[0]&&assertNodeType(n[0],"raw").string;let a="";if(o){const e=assertNodeType(r[0],"raw").string;a=colorFromSpec(o,e)}else{a=validateColor(assertNodeType(r[0],"raw").string,e.gullet.macros)}const i=r[1];return{type:"enclose",mode:e.mode,label:t,backgroundColor:a,body:i}},mathmlBuilder:mathmlBuilder$8});defineFunction({type:"enclose",names:["\\fcolorbox"],props:{numArgs:3,numOptionalArgs:1,allowedInText:true,argTypes:["raw","raw","raw","text"]},handler({parser:e,funcName:t},r,n){const o=n[0]&&assertNodeType(n[0],"raw").string;let a="";let i;if(o){const e=assertNodeType(r[0],"raw").string;const t=assertNodeType(r[0],"raw").string;a=colorFromSpec(o,e);i=colorFromSpec(o,t)}else{a=validateColor(assertNodeType(r[0],"raw").string,e.gullet.macros);i=validateColor(assertNodeType(r[1],"raw").string,e.gullet.macros)}const s=r[2];return{type:"enclose",mode:e.mode,label:t,backgroundColor:i,borderColor:a,body:s}},mathmlBuilder:mathmlBuilder$8});defineFunction({type:"enclose",names:["\\fbox"],props:{numArgs:1,argTypes:["hbox"],allowedInText:true},handler({parser:e},t){return{type:"enclose",mode:e.mode,label:"\\fbox",body:t[0]}}});defineFunction({type:"enclose",names:["\\angl","\\cancel","\\bcancel","\\xcancel","\\sout","\\overline"],props:{numArgs:1},handler({parser:e,funcName:t},r){const n=r[0];return{type:"enclose",mode:e.mode,label:t,body:n}},mathmlBuilder:mathmlBuilder$8});defineFunction({type:"enclose",names:["\\underline"],props:{numArgs:1,allowedInText:true},handler({parser:e,funcName:t},r){const n=r[0];return{type:"enclose",mode:e.mode,label:t,body:n}},mathmlBuilder:mathmlBuilder$8});const _environments={};function defineEnvironment({type:e,names:t,props:r,handler:n,mathmlBuilder:o}){const a={type:e,numArgs:r.numArgs||0,allowedInText:false,numOptionalArgs:0,handler:n};for(let e=0;e<t.length;++e){_environments[t[e]]=a}if(o){_mathmlGroupBuilders[e]=o}}const StyleLevel={DISPLAY:0,TEXT:1,SCRIPT:2,SCRIPTSCRIPT:3};function getHLines(e){const t=[];e.consumeSpaces();let r=e.fetch().text;if(r==="\\relax"){e.consume();e.consumeSpaces();r=e.fetch().text}while(r==="\\hline"||r==="\\hdashline"){e.consume();t.push(r==="\\hdashline");e.consumeSpaces();r=e.fetch().text}return t}const validateAmsEnvironmentContext=e=>{const t=e.parser.settings;if(!t.displayMode){throw new ParseError(`{${e.envName}} can be used only in display mode.`)}};const getTag=(e,t,r)=>{let n;const o=e.tags.shift();if(o){if(o.body){n=buildExpressionRow(o.body,t);n.classes=["tml-tag"]}else{n=new mathMLTree.MathNode("mtext",[],[]);return n}}else if(e.envClasses.includes("multline")&&(e.leqno&&r!==0||!e.leqno&&r!==e.body.length-1)){n=new mathMLTree.MathNode("mtext",[],[]);return n}else{n=new mathMLTree.MathNode("mtext",[],["tml-eqn"])}return n};function parseArray(e,{cols:t,envClasses:r,addEqnNum:n,singleRow:o,emptySingleRow:a,maxNumCols:i,leqno:s},l){e.gullet.beginGroup();if(!o){e.gullet.macros.set("\\cr","\\\\\\relax")}if(n){e.gullet.macros.set("\\tag","\\env@tag{\\text{#1}}");e.gullet.macros.set("\\notag","\\env@notag");e.gullet.macros.set("\\nonumber","\\env@notag")}e.gullet.beginGroup();let m=[];const d=[m];const c=[];const u=[];let h;const p=[];p.push(getHLines(e));while(true){let t=e.parseExpression(false,o?"\\end":"\\\\");if(n&&!h){for(let e=0;e<t.length;e++){if(t[e].type==="envTag"||t[e].type==="noTag"){h=t[e].type==="envTag"?t.splice(e,1)[0].body.body[0]:{body:null};break}}}e.gullet.endGroup();e.gullet.beginGroup();t={type:"ordgroup",mode:e.mode,body:t};m.push(t);const s=e.fetch().text;if(s==="&"){if(i&&m.length===i){if(r.includes("array")){if(e.settings.strict){throw new ParseError("Too few columns "+"specified in the {array} column argument.",e.nextToken)}}else if(i===2){throw new ParseError("The split environment accepts no more than two columns",e.nextToken)}else{throw new ParseError("The equation environment accepts only one column",e.nextToken)}}e.consume()}else if(s==="\\end"){if(m.length===1&&t.body.length===0&&(d.length>1||!a)){d.pop()}if(p.length<d.length+1){p.push([])}break}else if(s==="\\\\"){e.consume();let t;if(e.gullet.future().text!==" "){t=e.parseSizeGroup(true)}c.push(t?t.value:null);u.push(h);p.push(getHLines(e));m=[];h=null;d.push(m)}else{throw new ParseError("Expected & or \\\\ or \\cr or \\end",e.nextToken)}}e.gullet.endGroup();e.gullet.endGroup();u.push(h);return{type:"array",mode:e.mode,body:d,cols:t,rowGaps:c,hLinesBeforeRow:p,envClasses:r,addEqnNum:n,scriptLevel:l,tags:u,leqno:s}}function dCellStyle(e){return e.slice(0,1)==="d"?"display":"text"}const alignMap={c:"center ",l:"left ",r:"right "};const glue=e=>{const t=new mathMLTree.MathNode("mtd",[]);t.style={padding:"0",width:"50%"};if(e.envClasses.includes("multline")){t.style.width="7.5%"}return t};const mathmlBuilder$7=function(e,t){const r=[];const n=e.body.length;const o=e.hLinesBeforeRow;for(let a=0;a<n;a++){const i=e.body[a];const s=[];const l=e.scriptLevel==="text"?StyleLevel.TEXT:e.scriptLevel==="script"?StyleLevel.SCRIPT:StyleLevel.DISPLAY;for(let r=0;r<i.length;r++){const o=new mathMLTree.MathNode("mtd",[buildGroup$1(i[r],t.withLevel(l))]);if(e.envClasses.includes("multline")){const e=a===0?"left":a===n-1?"right":"center";o.setAttribute("columnalign",e);if(e!=="center"){o.style.textAlign="-webkit-"+e}}s.push(o)}if(e.addEqnNum){s.unshift(glue(e));s.push(glue(e));const r=getTag(e,t.withLevel(l),a);if(e.leqno){s[0].children.push(r);s[0].style.textAlign="-webkit-left"}else{s[s.length-1].children.push(r);s[s.length-1].style.textAlign="-webkit-right"}}const m=new mathMLTree.MathNode("mtr",s,[]);if(a===0&&o[0].length>0){if(o[0].length===2){m.classes.push("tml-top-double")}else{m.classes.push(o[0][0]?"tml-top-dashed":"tml-top-solid")}}if(o[a+1].length>0){if(o[a+1].length===2){m.classes.push("tml-hline-double")}else{m.classes.push(o[a+1][0]?"tml-hline-dashed":"tml-hline-solid")}}r.push(m)}let a=new mathMLTree.MathNode("mtable",r);if(e.envClasses.length>0){a.classes=e.envClasses.map((e=>"tml-"+e))}if(e.scriptLevel==="display"){a.setAttribute("displaystyle","true")}if(e.addEqnNum||e.envClasses.includes("multline")){a.style.width="100%"}let i="";if(e.cols&&e.cols.length>0){const t=e.cols;let r=false;let n=0;let o=t.length;while(t[n].type==="separator"){n+=1}while(t[o-1].type==="separator"){o-=1}if(t[0].type==="separator"){const e=t[1].type==="separator"?"0.15em double":t[0].separator==="|"?"0.06em solid ":"0.06em dashed ";for(const t of a.children){t.children[0].style.borderLeft=e}}let s=e.addEqnNum?0:-1;for(let e=n;e<o;e++){if(t[e].type==="align"){const n=alignMap[t[e].align];i+=n;s+=1;for(const e of a.children){if(n.trim()!=="center"&&s<e.children.length){e.children[s].style.textAlign="-webkit-"+n.trim()}}r=true}else if(t[e].type==="separator"){if(r){const r=t[e+1].type==="separator"?"0.15em double":t[e].separator==="|"?"0.06em solid":"0.06em dashed";for(const e of a.children){if(s<e.children.length){e.children[s].style.borderRight=r}}}r=false}}if(t[t.length-1].type==="separator"){const e=t[t.length-2].type==="separator"?"0.15em double":t[t.length-1].separator==="|"?"0.06em solid":"0.06em dashed";for(const t of a.children){t.children[t.children.length-1].style.borderRight=e;t.children[t.children.length-1].style.paddingRight="0.4em"}}}if(e.addEqnNum){i="left "+(i.length>0?i:"center ")+"right "}if(i){a.setAttribute("columnalign",i.trim())}if(e.envClasses.includes("small")){a=new mathMLTree.MathNode("mstyle",[a]);a.setAttribute("scriptlevel","1")}return a};const alignedHandler=function(e,t){if(e.envName.indexOf("ed")===-1){validateAmsEnvironmentContext(e)}const r=[];const n=parseArray(e.parser,{cols:r,addEqnNum:e.envName==="align"||e.envName==="alignat",emptySingleRow:true,envClasses:["jot","abut"],maxNumCols:e.envName==="split"?2:undefined,leqno:e.parser.settings.leqno},"display");let o;let a=0;if(t[0]&&t[0].type==="ordgroup"){let e="";for(let r=0;r<t[0].body.length;r++){const n=assertNodeType(t[0].body[r],"textord");e+=n.text}o=Number(e);a=o*2}const i=!a;n.body.forEach((function(e){if(!i){const t=e.length/2;if(o<t){throw new ParseError("Too many math in a row: "+`expected ${o}, but got ${t}`,e[0])}}else if(a<e.length){a=e.length}}));for(let e=0;e<a;++e){let t="r";if(e%2===1){t="l"}r[e]={type:"align",align:t}}if(e.envName==="split");else if(e.envName.indexOf("ed")>-1){n.envClasses.push("aligned")}else if(i){n.envClasses[1]=e.envName==="align*"?"align-star":"align"}else{n.envClasses.push("aligned")}return n};defineEnvironment({type:"array",names:["array","darray"],props:{numArgs:1},handler(e,t){const r=checkSymbolNodeType(t[0]);const n=r?[t[0]]:assertNodeType(t[0],"ordgroup").body;const o=n.map((function(e){const t=assertSymbolNodeType(e);const r=t.text;if("lcr".indexOf(r)!==-1){return{type:"align",align:r}}else if(r==="|"){return{type:"separator",separator:"|"}}else if(r===":"){return{type:"separator",separator:":"}}throw new ParseError("Unknown column alignment: "+r,e)}));const a={cols:o,envClasses:["array"],maxNumCols:o.length};return parseArray(e.parser,a,dCellStyle(e.envName))},mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["matrix","pmatrix","bmatrix","Bmatrix","vmatrix","Vmatrix","matrix*","pmatrix*","bmatrix*","Bmatrix*","vmatrix*","Vmatrix*"],props:{numArgs:0},handler(e){const t={matrix:null,pmatrix:["(",")"],bmatrix:["[","]"],Bmatrix:["\\{","\\}"],vmatrix:["|","|"],Vmatrix:["\\Vert","\\Vert"]}[e.envName.replace("*","")];let r="c";const n={envClasses:[],cols:[]};if(e.envName.charAt(e.envName.length-1)==="*"){const t=e.parser;t.consumeSpaces();if(t.fetch().text==="["){t.consume();t.consumeSpaces();r=t.fetch().text;if("lcr".indexOf(r)===-1){throw new ParseError("Expected l or c or r",t.nextToken)}t.consume();t.consumeSpaces();t.expect("]");t.consume();n.cols=[]}}const o=parseArray(e.parser,n,"text");o.cols=new Array(o.body[0].length).fill({type:"align",align:r});return t?{type:"leftright",mode:e.mode,body:[o],left:t[0],right:t[1],rightColor:undefined}:o},mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["smallmatrix"],props:{numArgs:0},handler(e){const t={type:"small"};const r=parseArray(e.parser,t,"script");r.envClasses=["small"];return r},mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["subarray"],props:{numArgs:1},handler(e,t){const r=checkSymbolNodeType(t[0]);const n=r?[t[0]]:assertNodeType(t[0],"ordgroup").body;const o=n.map((function(e){const t=assertSymbolNodeType(e);const r=t.text;if("lc".indexOf(r)!==-1){return{type:"align",align:r}}throw new ParseError("Unknown column alignment: "+r,e)}));if(o.length>1){throw new ParseError("{subarray} can contain only one column")}let a={cols:o,envClasses:["small"]};a=parseArray(e.parser,a,"script");if(a.body.length>0&&a.body[0].length>1){throw new ParseError("{subarray} can contain only one column")}return a},mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["cases","dcases","rcases","drcases"],props:{numArgs:0},handler(e){const t={cols:[],envClasses:["cases"]};const r=parseArray(e.parser,t,dCellStyle(e.envName));return{type:"leftright",mode:e.mode,body:[r],left:e.envName.indexOf("r")>-1?".":"\\{",right:e.envName.indexOf("r")>-1?"\\}":".",rightColor:undefined}},mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["align","align*","aligned","split"],props:{numArgs:0},handler:alignedHandler,mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["alignat","alignat*","alignedat"],props:{numArgs:1},handler:alignedHandler,mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["gathered","gather","gather*"],props:{numArgs:0},handler(e){if(e.envName!=="gathered"){validateAmsEnvironmentContext(e)}const t={cols:[],envClasses:["jot","abut"],addEqnNum:e.envName==="gather",emptySingleRow:true,leqno:e.parser.settings.leqno};return parseArray(e.parser,t,"display")},mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["equation","equation*"],props:{numArgs:0},handler(e){validateAmsEnvironmentContext(e);const t={addEqnNum:e.envName==="equation",emptySingleRow:true,singleRow:true,maxNumCols:1,envClasses:["align"],leqno:e.parser.settings.leqno};return parseArray(e.parser,t,"display")},mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["multline","multline*"],props:{numArgs:0},handler(e){validateAmsEnvironmentContext(e);const t={addEqnNum:e.envName==="multline",maxNumCols:1,envClasses:["jot","multline"],leqno:e.parser.settings.leqno};return parseArray(e.parser,t,"display")},mathmlBuilder:mathmlBuilder$7});defineEnvironment({type:"array",names:["CD"],props:{numArgs:0},handler(e){validateAmsEnvironmentContext(e);return parseCD(e.parser)},mathmlBuilder:mathmlBuilder$7});defineFunction({type:"text",names:["\\hline","\\hdashline"],props:{numArgs:0,allowedInText:true,allowedInMath:true},handler(e,t){throw new ParseError(`${e.funcName} valid only within array environment`)}});const environments=_environments;defineFunction({type:"environment",names:["\\begin","\\end"],props:{numArgs:1,argTypes:["text"]},handler({parser:e,funcName:t},r){const n=r[0];if(n.type!=="ordgroup"){throw new ParseError("Invalid environment name",n)}let o="";for(let e=0;e<n.body.length;++e){o+=assertNodeType(n.body[e],"textord").text}if(t==="\\begin"){if(!Object.prototype.hasOwnProperty.call(environments,o)){throw new ParseError("No such environment: "+o,n)}const t=environments[o];const{args:r,optArgs:a}=e.parseArguments("\\begin{"+o+"}",t);const i={mode:e.mode,envName:o,parser:e};const s=t.handler(i,r,a);e.expect("\\end",false);const l=e.nextToken;const m=assertNodeType(e.parseFunction(),"environment");if(m.name!==o){throw new ParseError(`Mismatch: \\begin{${o}} matched by \\end{${m.name}}`,l)}return s}return{type:"environment",mode:e.mode,name:o,nameGroup:n}}});defineFunction({type:"envTag",names:["\\env@tag"],props:{numArgs:1,argTypes:["math"]},handler({parser:e},t){return{type:"envTag",mode:e.mode,body:t[0]}},mathmlBuilder(e,t){return new mathMLTree.MathNode("mrow")}});defineFunction({type:"noTag",names:["\\env@notag"],props:{numArgs:0},handler({parser:e}){return{type:"noTag",mode:e.mode}},mathmlBuilder(e,t){return new mathMLTree.MathNode("mrow")}});const mathmlBuilder$6=(e,t)=>{const r=e.font;const n=t.withFont(r);const o=buildGroup$1(e.body,n);if(o.children.length===0){return o}if(r==="boldsymbol"&&["mo","mpadded"].includes(o.type)){o.style.fontWeight="bold";return o}let a=o.children[0].type==="mo";for(let e=1;e<o.children.length;e++){if(o.children[e].type==="mo"&&r==="boldsymbol"){o.children[e].style.fontWeight="bold"}if(o.children[e].type!=="mi"){a=false}const t=o.children[e].attributes&&o.children[e].attributes.mathvariant||"";if(t!=="normal"){a=false}}if(!a){return o}const i=o.children[0];for(let e=1;e<o.children.length;e++){i.children.push(o.children[e].children[0])}if(o.attributes.mathcolor){i.attributes.mathcolor=o.attributes.mathcolor}if(i.attributes.mathvariant&&i.attributes.mathvariant==="normal"){const e=new mathMLTree.MathNode("mtext",new mathMLTree.TextNode("​"));return new mathMLTree.MathNode("mrow",[e,i])}return i};const fontAliases={"\\Bbb":"\\mathbb","\\bold":"\\mathbf","\\frak":"\\mathfrak","\\bm":"\\boldsymbol"};defineFunction({type:"font",names:["\\mathrm","\\mathit","\\mathbf","\\mathnormal","\\up@greek","\\boldsymbol","\\mathbb","\\mathcal","\\mathfrak","\\mathscr","\\mathsf","\\mathtt","\\Bbb","\\bm","\\bold","\\frak"],props:{numArgs:1,allowedInArgument:true},handler:({parser:e,funcName:t},r)=>{const n=normalizeArgument(r[0]);let o=t;if(o in fontAliases){o=fontAliases[o]}return{type:"font",mode:e.mode,font:o.slice(1),body:n}},mathmlBuilder:mathmlBuilder$6});defineFunction({type:"font",names:["\\rm","\\sf","\\tt","\\bf","\\it","\\cal"],props:{numArgs:0,allowedInText:true},handler:({parser:e,funcName:t,breakOnTokenText:r},n)=>{const{mode:o}=e;const a=e.parseExpression(true,r);const i=`math${t.slice(1)}`;return{type:"font",mode:o,font:i,body:{type:"ordgroup",mode:e.mode,body:a}}},mathmlBuilder:mathmlBuilder$6});const stylArray=["display","text","script","scriptscript"];const scriptLevel={auto:-1,display:0,text:0,script:1,scriptscript:2};const mathmlBuilder$5=(e,t)=>{const r=e.scriptLevel==="auto"?t.incrementLevel():e.scriptLevel==="display"?t.withLevel(StyleLevel.TEXT):e.scriptLevel==="text"?t.withLevel(StyleLevel.SCRIPT):t.withLevel(StyleLevel.SCRIPTSCRIPT);let n=new mathMLTree.MathNode("mfrac",[buildGroup$1(e.numer,r),buildGroup$1(e.denom,r)]);if(!e.hasBarLine){n.setAttribute("linethickness","0px")}else if(e.barSize){const r=calculateSize(e.barSize,t);n.setAttribute("linethickness",r.number+r.unit)}if(e.leftDelim!=null||e.rightDelim!=null){const t=[];if(e.leftDelim!=null){const r=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode(e.leftDelim.replace("\\",""))]);r.setAttribute("fence","true");t.push(r)}t.push(n);if(e.rightDelim!=null){const r=new mathMLTree.MathNode("mo",[new mathMLTree.TextNode(e.rightDelim.replace("\\",""))]);r.setAttribute("fence","true");t.push(r)}n=makeRow(t)}if(e.scriptLevel!=="auto"){n=new mathMLTree.MathNode("mstyle",[n]);n.setAttribute("displaystyle",String(e.scriptLevel==="display"));n.setAttribute("scriptlevel",scriptLevel[e.scriptLevel])}return n};defineFunction({type:"genfrac",names:["\\dfrac","\\frac","\\tfrac","\\dbinom","\\binom","\\tbinom","\\\\atopfrac","\\\\bracefrac","\\\\brackfrac"],props:{numArgs:2,allowedInArgument:true},handler:({parser:e,funcName:t},r)=>{const n=r[0];const o=r[1];let a=false;let i=null;let s=null;let l="auto";switch(t){case"\\dfrac":case"\\frac":case"\\tfrac":a=true;break;case"\\\\atopfrac":a=false;break;case"\\dbinom":case"\\binom":case"\\tbinom":i="(";s=")";break;case"\\\\bracefrac":i="\\{";s="\\}";break;case"\\\\brackfrac":i="[";s="]";break;default:throw new Error("Unrecognized genfrac command")}switch(t){case"\\dfrac":case"\\dbinom":l="display";break;case"\\tfrac":case"\\tbinom":l="text";break}return{type:"genfrac",mode:e.mode,continued:false,numer:n,denom:o,hasBarLine:a,leftDelim:i,rightDelim:s,scriptLevel:l,barSize:null}},mathmlBuilder:mathmlBuilder$5});defineFunction({type:"genfrac",names:["\\cfrac"],props:{numArgs:2},handler:({parser:e,funcName:t},r)=>{const n=r[0];const o=r[1];return{type:"genfrac",mode:e.mode,continued:true,numer:n,denom:o,hasBarLine:true,leftDelim:null,rightDelim:null,scriptLevel:"display",barSize:null}}});defineFunction({type:"infix",names:["\\over","\\choose","\\atop","\\brace","\\brack"],props:{numArgs:0,infix:true},handler({parser:e,funcName:t,token:r}){let n;switch(t){case"\\over":n="\\frac";break;case"\\choose":n="\\binom";break;case"\\atop":n="\\\\atopfrac";break;case"\\brace":n="\\\\bracefrac";break;case"\\brack":n="\\\\brackfrac";break;default:throw new Error("Unrecognized infix genfrac command")}return{type:"infix",mode:e.mode,replaceWith:n,token:r}}});const delimFromValue=function(e){let t=null;if(e.length>0){t=e;t=t==="."?null:t}return t};defineFunction({type:"genfrac",names:["\\genfrac"],props:{numArgs:6,allowedInArgument:true,argTypes:["math","math","size","text","math","math"]},handler({parser:e},t){const r=t[4];const n=t[5];const o=normalizeArgument(t[0]);const a=o.type==="atom"&&o.family==="open"?delimFromValue(o.text):null;const i=normalizeArgument(t[1]);const s=i.type==="atom"&&i.family==="close"?delimFromValue(i.text):null;const l=assertNodeType(t[2],"size");let m;let d=null;if(l.isBlank){m=true}else{d=l.value;m=d.number>0}let c="auto";let u=t[3];if(u.type==="ordgroup"){if(u.body.length>0){const e=assertNodeType(u.body[0],"textord");c=stylArray[Number(e.text)]}}else{u=assertNodeType(u,"textord");c=stylArray[Number(u.text)]}return{type:"genfrac",mode:e.mode,numer:r,denom:n,continued:false,hasBarLine:m,barSize:d,leftDelim:a,rightDelim:s,scriptLevel:c}},mathmlBuilder:mathmlBuilder$5});defineFunction({type:"infix",names:["\\above"],props:{numArgs:1,argTypes:["size"],infix:true},handler({parser:e,funcName:t,token:r},n){return{type:"infix",mode:e.mode,replaceWith:"\\\\abovefrac",barSize:assertNodeType(n[0],"size").value,token:r}}});defineFunction({type:"genfrac",names:["\\\\abovefrac"],props:{numArgs:3,argTypes:["math","size","math"]},handler:({parser:e,funcName:t},r)=>{const n=r[0];const o=assert(assertNodeType(r[1],"infix").barSize);const a=r[2];const i=o.number>0;return{type:"genfrac",mode:e.mode,numer:n,denom:a,continued:false,hasBarLine:i,barSize:o,leftDelim:null,rightDelim:null,scriptLevel:"auto"}},mathmlBuilder:mathmlBuilder$5});const mathmlBuilder$4=(e,t)=>{const r=stretchy.mathMLnode(e.label);r.style["math-depth"]=0;return new mathMLTree.MathNode(e.isOver?"mover":"munder",[buildGroup$1(e.base,t),r])};defineFunction({type:"horizBrace",names:["\\overbrace","\\underbrace"],props:{numArgs:1},handler({parser:e,funcName:t},r){return{type:"horizBrace",mode:e.mode,label:t,isOver:/^\\over/.test(t),base:r[0]}},mathmlBuilder:mathmlBuilder$4});defineFunction({type:"href",names:["\\href"],props:{numArgs:2,argTypes:["url","original"],allowedInText:true},handler:({parser:e,token:t},r)=>{const n=r[1];const o=assertNodeType(r[0],"url").url;if(!e.settings.isTrusted({command:"\\href",url:o})){throw new ParseError(`Function "\\href" is not trusted`,t)}return{type:"href",mode:e.mode,href:o,body:ordargument(n)}},mathmlBuilder:(e,t)=>{let r=buildExpressionRow(e.body,t);if(!(r instanceof MathNode)){r=new MathNode("mrow",[r])}r.setAttribute("href",e.href);return r}});defineFunction({type:"href",names:["\\url"],props:{numArgs:1,argTypes:["url"],allowedInText:true},handler:({parser:e,token:t},r)=>{const n=assertNodeType(r[0],"url").url;if(!e.settings.isTrusted({command:"\\url",url:n})){throw new ParseError(`Function "\\url" is not trusted`,t)}const o=[];for(let e=0;e<n.length;e++){let t=n[e];if(t==="~"){t="\\textasciitilde"}o.push({type:"textord",mode:"text",text:t})}const a={type:"text",mode:e.mode,font:"\\texttt",body:o};return{type:"href",mode:e.mode,href:n,body:ordargument(a)}}});defineFunction({type:"html",names:["\\class","\\id","\\style","\\data"],props:{numArgs:2,argTypes:["raw","original"],allowedInText:true},handler:({parser:e,funcName:t,token:r},n)=>{const o=assertNodeType(n[0],"raw").string;const a=n[1];if(e.settings.strict){throw new ParseError(`Function "${t}" is disabled in strict mode`,r)}let i;const s={};switch(t){case"\\class":s.class=o;i={command:"\\class",class:o};break;case"\\id":s.id=o;i={command:"\\id",id:o};break;case"\\style":s.style=o;i={command:"\\style",style:o};break;case"\\data":{const e=o.split(",");for(let t=0;t<e.length;t++){const r=e[t].split("=");if(r.length!==2){throw new ParseError("Error parsing key-value for \\data")}s["data-"+r[0].trim()]=r[1].trim()}i={command:"\\data",attributes:s};break}default:throw new Error("Unrecognized html command")}if(!e.settings.isTrusted(i)){throw new ParseError(`Function "${t}" is not trusted`,r)}return{type:"html",mode:e.mode,attributes:s,body:ordargument(a)}},mathmlBuilder:(e,t)=>{const r=buildExpressionRow(e.body,t);const n=[];if(e.attributes.class){n.push(...e.attributes.class.trim().split(/\s+/))}r.classes=n;for(const t in e.attributes){if(t!=="class"&&Object.prototype.hasOwnProperty.call(e.attributes,t)){r.setAttribute(t,e.attributes[t])}}return r}});const sizeData=function(e){if(/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e)){return{number:+e,unit:"bp"}}else{const t=/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);if(!t){throw new ParseError("Invalid size: '"+e+"' in \\includegraphics")}const r={number:+(t[1]+t[2]),unit:t[3]};if(!validUnit(r)){throw new ParseError("Invalid unit: '"+r.unit+"' in \\includegraphics.")}return r}};defineFunction({type:"includegraphics",names:["\\includegraphics"],props:{numArgs:1,numOptionalArgs:1,argTypes:["raw","url"],allowedInText:false},handler:({parser:e,token:t},r,n)=>{let o={number:0,unit:"em"};let a={number:.9,unit:"em"};let i={number:0,unit:"em"};let s="";if(n[0]){const e=assertNodeType(n[0],"raw").string;const t=e.split(",");for(let e=0;e<t.length;e++){const r=t[e].split("=");if(r.length===2){const e=r[1].trim();switch(r[0].trim()){case"alt":s=e;break;case"width":o=sizeData(e);break;case"height":a=sizeData(e);break;case"totalheight":i=sizeData(e);break;default:throw new ParseError("Invalid key: '"+r[0]+"' in \\includegraphics.")}}}}const l=assertNodeType(r[0],"url").url;if(s===""){s=l;s=s.replace(/^.*[\\/]/,"");s=s.substring(0,s.lastIndexOf("."))}if(!e.settings.isTrusted({command:"\\includegraphics",url:l})){throw new ParseError(`Function "\\includegraphics" is not trusted`,t)}return{type:"includegraphics",mode:e.mode,alt:s,width:o,height:a,totalheight:i,src:l}},mathmlBuilder:(e,t)=>{const r=calculateSize(e.height,t);const n={number:0,unit:"em"};if(e.totalheight.number>0){if(e.totalheight.unit===r.unit&&e.totalheight.number>r.number){n.number=e.totalheight.number-r.number;n.unit=r.unit}}let o=0;if(e.width.number>0){o=calculateSize(e.width,t)}const a={height:r.number+n.number+"em"};if(o.number>0){a.width=o.number+o.unit}if(n.number>0){a.verticalAlign=-n.number+n.unit}const i=new Img(e.src,e.alt,a);i.height=r;i.depth=n;return new mathMLTree.MathNode("mtext",[i])}});defineFunction({type:"kern",names:["\\kern","\\mkern","\\hskip","\\mskip"],props:{numArgs:1,argTypes:["size"],primitive:true,allowedInText:true},handler({parser:e,funcName:t,token:r},n){const o=assertNodeType(n[0],"size");if(e.settings.strict){const n=t[1]==="m";const a=o.value.unit==="mu";if(n){if(!a){throw new ParseError(`LaTeX's ${t} supports only mu units, `+`not ${o.value.unit} units`,r)}if(e.mode!=="math"){throw new ParseError(`LaTeX's ${t} works only in math mode`,r)}}else{if(a){throw new ParseError(`LaTeX's ${t} doesn't support mu units`,r)}}}return{type:"kern",mode:e.mode,dimension:o.value}},mathmlBuilder(e,t){const r=calculateSize(e.dimension,t);const n=r.unit==="em"?spaceCharacter(r.number):"";if(e.mode==="text"&&n.length>0){const e=new mathMLTree.TextNode(n);return new mathMLTree.MathNode("mtext",[e])}else{const e=new mathMLTree.MathNode("mspace");e.setAttribute("width",r.number+r.unit);if(r.number<0){e.style.marginLeft=r.number+r.unit}return e}}});const spaceCharacter=function(e){if(e>=.05555&&e<=.05556){return" "}else if(e>=.1666&&e<=.1667){return" "}else if(e>=.2222&&e<=.2223){return" "}else if(e>=.2777&&e<=.2778){return"  "}else{return""}};const invalidIdRegEx=/[^A-Za-z_0-9-]/g;defineFunction({type:"label",names:["\\label"],props:{numArgs:1,argTypes:["raw"]},handler({parser:e},t){return{type:"label",mode:e.mode,string:t[0].string.replace(invalidIdRegEx,"")}},mathmlBuilder(e,t){const r=new mathMLTree.MathNode("mrow",[],["tml-label"]);if(e.string.length>0){r.setAttribute("id",e.string)}return r}});const textModeLap=["\\clap","\\llap","\\rlap"];defineFunction({type:"lap",names:["\\mathllap","\\mathrlap","\\mathclap","\\clap","\\llap","\\rlap"],props:{numArgs:1,allowedInText:true},handler:({parser:e,funcName:t,token:r},n)=>{if(textModeLap.includes(t)){if(e.settings.strict&&e.mode!=="text"){throw new ParseError(`{${t}} can be used only in text mode.\n Try \\math${t.slice(1)}`,r)}t=t.slice(1)}else{t=t.slice(5)}const o=n[0];return{type:"lap",mode:e.mode,alignment:t,body:o}},mathmlBuilder:(e,t)=>{let r;if(e.alignment==="llap"){const n=buildExpression(ordargument(e.body),t);const o=new mathMLTree.MathNode("mphantom",n);r=new mathMLTree.MathNode("mpadded",[o]);r.setAttribute("width","0px")}const n=buildGroup$1(e.body,t);let o;if(e.alignment==="llap"){n.style.position="absolute";n.style.right="0";n.style.bottom=`0`;o=new mathMLTree.MathNode("mpadded",[r,n])}else{o=new mathMLTree.MathNode("mpadded",[n])}if(e.alignment==="rlap"){if(e.body.body.length>0&&e.body.body[0].type==="genfrac"){o.setAttribute("lspace","0.16667em")}}else{const t=e.alignment==="llap"?"-1":"-0.5";o.setAttribute("lspace",t+"width");if(e.alignment==="llap"){o.style.position="relative"}else{o.style.display="flex";o.style.justifyContent="center"}}o.setAttribute("width","0px");return o}});defineFunction({type:"ordgroup",names:["\\(","$"],props:{numArgs:0,allowedInText:true,allowedInMath:false},handler({funcName:e,parser:t},r){const n=t.mode;t.switchMode("math");const o=e==="\\("?"\\)":"$";const a=t.parseExpression(false,o);t.expect(o);t.switchMode(n);return{type:"ordgroup",mode:t.mode,body:a}}});defineFunction({type:"text",names:["\\)","\\]"],props:{numArgs:0,allowedInText:true,allowedInMath:false},handler(e,t){throw new ParseError(`Mismatched ${e.funcName}`,t)}});const chooseStyle=(e,t)=>{switch(t.level){case StyleLevel.DISPLAY:return e.display;case StyleLevel.TEXT:return e.text;case StyleLevel.SCRIPT:return e.script;case StyleLevel.SCRIPTSCRIPT:return e.scriptscript;default:return e.text}};defineFunction({type:"mathchoice",names:["\\mathchoice"],props:{numArgs:4,primitive:true},handler:({parser:e},t)=>({type:"mathchoice",mode:e.mode,display:ordargument(t[0]),text:ordargument(t[1]),script:ordargument(t[2]),scriptscript:ordargument(t[3])}),mathmlBuilder:(e,t)=>{const r=chooseStyle(e,t);return buildExpressionRow(r,t)}});const textAtomTypes=["text","textord","mathord","atom"];const padding=e=>{const t=new mathMLTree.MathNode("mspace");t.setAttribute("width",e+"em");return t};function mathmlBuilder$3(e,t){let r;const n=buildExpression(e.body,t);if(e.mclass==="minner"){r=new mathMLTree.MathNode("mpadded",n)}else if(e.mclass==="mord"){if(e.isCharacterBox||n[0].type==="mathord"){r=n[0];r.type="mi"}else{r=new mathMLTree.MathNode("mi",n)}}else{r=new mathMLTree.MathNode("mrow",n);if(e.mustPromote){r=n[0];r.type="mo";if(e.isCharacterBox&&e.body[0].text&&/[A-Za-z]/.test(e.body[0].text)){r.setAttribute("mathvariant","italic")}}else{r=new mathMLTree.MathNode("mrow",n)}const o=t.level<2;if(r.type==="mrow"){if(o){if(e.mclass==="mbin"){r.children.unshift(padding(.2222));r.children.push(padding(.2222))}else if(e.mclass==="mrel"){r.children.unshift(padding(.2778));r.children.push(padding(.2778))}else if(e.mclass==="mpunct"){r.children.push(padding(.1667))}else if(e.mclass==="minner"){r.children.unshift(padding(.0556));r.children.push(padding(.0556))}}}else{if(e.mclass==="mbin"){r.attributes.lspace=o?"0.2222em":"0";r.attributes.rspace=o?"0.2222em":"0"}else if(e.mclass==="mrel"){r.attributes.lspace=o?"0.2778em":"0";r.attributes.rspace=o?"0.2778em":"0"}else if(e.mclass==="mpunct"){r.attributes.lspace="0em";r.attributes.rspace=o?"0.1667em":"0"}else if(e.mclass==="mopen"||e.mclass==="mclose"){r.attributes.lspace="0em";r.attributes.rspace="0em"}else if(e.mclass==="minner"&&o){r.attributes.lspace="0.0556em";r.attributes.width="+0.1111em"}}if(!(e.mclass==="mopen"||e.mclass==="mclose")){delete r.attributes.stretchy;delete r.attributes.form}}return r}defineFunction({type:"mclass",names:["\\mathord","\\mathbin","\\mathrel","\\mathopen","\\mathclose","\\mathpunct","\\mathinner"],props:{numArgs:1,primitive:true},handler({parser:e,funcName:t},r){const n=r[0];const o=utils.isCharacterBox(n);let a=true;const i={type:"mathord",text:"",mode:e.mode};const s=n.body?n.body:[n];for(const e of s){if(textAtomTypes.includes(e.type)){if(e.text){i.text+=e.text}else if(e.body){e.body.map((e=>{i.text+=e.text}))}}else{a=false;break}}return{type:"mclass",mode:e.mode,mclass:"m"+t.slice(5),body:ordargument(a?i:n),isCharacterBox:o,mustPromote:a}},mathmlBuilder:mathmlBuilder$3});const binrelClass=e=>{const t=e.type==="ordgroup"&&e.body.length?e.body[0]:e;if(t.type==="atom"&&(t.family==="bin"||t.family==="rel")){return"m"+t.family}else{return"mord"}};defineFunction({type:"mclass",names:["\\@binrel"],props:{numArgs:2},handler({parser:e},t){return{type:"mclass",mode:e.mode,mclass:binrelClass(t[0]),body:ordargument(t[1]),isCharacterBox:utils.isCharacterBox(t[1])}}});defineFunction({type:"mclass",names:["\\stackrel","\\overset","\\underset"],props:{numArgs:2},handler({parser:e,funcName:t},r){const n=r[1];const o=r[0];const a={type:"op",mode:n.mode,limits:true,alwaysHandleSupSub:true,parentIsSupSub:false,symbol:false,stack:true,suppressBaseShift:t!=="\\stackrel",body:ordargument(n)};return{type:"supsub",mode:o.mode,base:a,sup:t==="\\underset"?null:o,sub:t==="\\underset"?o:null}},mathmlBuilder:mathmlBuilder$3});const buildGroup=(e,t,r)=>{if(!e){return r}const n=buildGroup$1(e,t);if(n.type==="mrow"&&n.children.length===0){return r}return n};defineFunction({type:"multiscript",names:["\\sideset","\\pres@cript"],props:{numArgs:3},handler({parser:e,funcName:t,token:r},n){if(n[2].body.length===0){throw new ParseError(t+`cannot parse an empty base.`)}const o=n[2].body[0];if(e.settings.strict&&t==="\\sideset"&&!o.symbol){throw new ParseError(`The base of \\sideset must be a big operator. Try \\prescript.`)}if(n[0].body.length>0&&n[0].body[0].type!=="supsub"||n[1].body.length>0&&n[1].body[0].type!=="supsub"){throw new ParseError("\\sideset can parse only subscripts and "+"superscripts in its first two arguments",r)}const a=n[0].body.length>0?n[0].body[0]:null;const i=n[1].body.length>0?n[1].body[0]:null;if(!a&&!i){return o}else if(!a){return{type:"styling",mode:e.mode,scriptLevel:"text",body:[{type:"supsub",mode:e.mode,base:o,sup:i.sup,sub:i.sub}]}}else{return{type:"multiscript",mode:e.mode,isSideset:t==="\\sideset",prescripts:a,postscripts:i,base:o}}},mathmlBuilder(e,t){const r=buildGroup$1(e.base,t);const n=new mathMLTree.MathNode("mprescripts");const o=new mathMLTree.MathNode("none");let a=[];const i=buildGroup(e.prescripts.sub,t,o);const s=buildGroup(e.prescripts.sup,t,o);if(e.isSideset){i.setAttribute("style","text-align: left;");s.setAttribute("style","text-align: left;")}if(e.postscripts){const l=buildGroup(e.postscripts.sub,t,o);const m=buildGroup(e.postscripts.sup,t,o);a=[r,l,m,n,i,s]}else{a=[r,n,i,s]}return new mathMLTree.MathNode("mmultiscripts",a)}});defineFunction({type:"not",names:["\\not"],props:{numArgs:1,primitive:true,allowedInText:false},handler({parser:e},t){const r=utils.isCharacterBox(t[0]);let n;if(r){n=ordargument(t[0]);if(n[0].text.charAt(0)==="\\"){n[0].text=symbols.math[n[0].text].replace}n[0].text=n[0].text.slice(0,1)+"̸"+n[0].text.slice(1)}else{const e={type:"textord",mode:"math",text:"̸"};const r={type:"kern",mode:"math",dimension:{number:-.6,unit:"em"}};n=[e,r,t[0]]}return{type:"not",mode:e.mode,body:n,isCharacterBox:r}},mathmlBuilder(e,t){if(e.isCharacterBox){const r=buildExpression(e.body,t);return r[0]}else{return buildExpressionRow(e.body,t,true)}}});const ordAtomTypes=["textord","mathord","atom"];const noSuccessor=["\\smallint"];const ordTypes=["textord","mathord","ordgroup","close","leftright"];const dels$1=["}","\\left","\\middle","\\right"];const isDelimiter$1=e=>e.length>0&&(delimiters.includes(e)||delimiterSizes[e]||dels$1.includes(e));const mathmlBuilder$2=(e,t)=>{let r;if(e.symbol){r=new MathNode("mo",[makeText(e.name,e.mode)]);if(noSuccessor.includes(e.name)){r.setAttribute("largeop","false")}else{r.setAttribute("movablelimits","false")}}else if(e.body){r=new MathNode("mo",buildExpression(e.body,t))}else{r=new MathNode("mi",[new TextNode(e.name.slice(1))]);if(!e.parentIsSupSub){const t=new MathNode("mo",[makeText("⁡","text")]);const n=[r,t];if(e.needsLeadingSpace){const e=new MathNode("mspace");e.setAttribute("width","0.1667em");n.unshift(e)}if(!e.isFollowedByDelimiter){const e=new MathNode("mspace");e.setAttribute("width","0.1667em");n.push(e)}r=new MathNode("mrow",n)}}return r};const singleCharBigOps={"∏":"\\prod","∐":"\\coprod","∑":"\\sum","⋀":"\\bigwedge","⋁":"\\bigvee","⋂":"\\bigcap","⋃":"\\bigcup","⨀":"\\bigodot","⨁":"\\bigoplus","⨂":"\\bigotimes","⨄":"\\biguplus","⨅":"\\bigsqcap","⨆":"\\bigsqcup"};defineFunction({type:"op",names:["\\coprod","\\bigvee","\\bigwedge","\\biguplus","\\bigcap","\\bigcup","\\intop","\\prod","\\sum","\\bigotimes","\\bigoplus","\\bigodot","\\bigsqcap","\\bigsqcup","\\smallint","∏","∐","∑","⋀","⋁","⋂","⋃","⨀","⨁","⨂","⨄","⨆"],props:{numArgs:0},handler:({parser:e,funcName:t},r)=>{let n=t;if(n.length===1){n=singleCharBigOps[n]}return{type:"op",mode:e.mode,limits:true,parentIsSupSub:false,symbol:true,stack:false,name:n}},mathmlBuilder:mathmlBuilder$2});defineFunction({type:"op",names:["\\mathop"],props:{numArgs:1,primitive:true},handler:({parser:e},t)=>{const r=t[0];const n=r.body?r.body:[r];const o=n.length===1&&ordAtomTypes.includes(n[0].type);return{type:"op",mode:e.mode,limits:true,parentIsSupSub:false,symbol:o,stack:false,name:o?n[0].text:null,body:o?null:ordargument(r)}},mathmlBuilder:mathmlBuilder$2});const singleCharIntegrals={"∫":"\\int","∬":"\\iint","∭":"\\iiint","∮":"\\oint","∯":"\\oiint","∰":"\\oiiint","∱":"\\intclockwise","∲":"\\varointclockwise","⨌":"\\iiiint","⨍":"\\intbar","⨎":"\\intBar","⨏":"\\fint","⨒":"\\rppolint","⨓":"\\scpolint","⨕":"\\pointint","⨖":"\\sqint","⨗":"\\intlarhk","⨘":"\\intx","⨙":"\\intcap","⨚":"\\intcup"};defineFunction({type:"op",names:["\\arcsin","\\arccos","\\arctan","\\arctg","\\arcctg","\\arg","\\ch","\\cos","\\cosec","\\cosh","\\cot","\\cotg","\\coth","\\csc","\\ctg","\\cth","\\deg","\\dim","\\exp","\\hom","\\ker","\\lg","\\ln","\\log","\\sec","\\sin","\\sinh","\\sh","\\sgn","\\tan","\\tanh","\\tg","\\th"],props:{numArgs:0},handler({parser:e,funcName:t}){const r=e.prevAtomType;const n=e.gullet.future().text;return{type:"op",mode:e.mode,limits:false,parentIsSupSub:false,symbol:false,stack:false,isFollowedByDelimiter:isDelimiter$1(n),needsLeadingSpace:r.length>0&&ordTypes.includes(r),name:t}},mathmlBuilder:mathmlBuilder$2});defineFunction({type:"op",names:["\\det","\\gcd","\\inf","\\lim","\\max","\\min","\\Pr","\\sup"],props:{numArgs:0},handler({parser:e,funcName:t}){const r=e.prevAtomType;const n=e.gullet.future().text;return{type:"op",mode:e.mode,limits:true,parentIsSupSub:false,symbol:false,stack:false,isFollowedByDelimiter:isDelimiter$1(n),needsLeadingSpace:r.length>0&&ordTypes.includes(r),name:t}},mathmlBuilder:mathmlBuilder$2});defineFunction({type:"op",names:["\\int","\\iint","\\iiint","\\iiiint","\\oint","\\oiint","\\oiiint","\\intclockwise","\\varointclockwise","\\intbar","\\intBar","\\fint","\\rppolint","\\scpolint","\\pointint","\\sqint","\\intlarhk","\\intx","\\intcap","\\intcup","∫","∬","∭","∮","∯","∰","∱","∲","⨌","⨍","⨎","⨏","⨒","⨓","⨕","⨖","⨗","⨘","⨙","⨚"],props:{numArgs:0},handler({parser:e,funcName:t}){let r=t;if(r.length===1){r=singleCharIntegrals[r]}return{type:"op",mode:e.mode,limits:false,parentIsSupSub:false,symbol:true,stack:false,name:r}},mathmlBuilder:mathmlBuilder$2});const _macros={};function defineMacro(e,t){_macros[e]=t}const dels=["}","\\left","\\middle","\\right"];const isDelimiter=e=>e.length>0&&(delimiters.includes(e)||delimiterSizes[e]||dels.includes(e));const mathmlBuilder$1=(e,t)=>{let r=buildExpression(e.body,t.withFont("mathrm"));let n=true;for(let e=0;e<r.length;e++){const t=r[e];if(t instanceof mathMLTree.MathNode){switch(t.type){case"mi":case"mn":case"ms":case"mtext":break;case"mspace":{if(t.attributes.width){const o=t.attributes.width.replace("em","");const a=spaceCharacter(Number(o));if(a===""){n=false}else{r[e]=new mathMLTree.MathNode("mtext",[new mathMLTree.TextNode(a)])}}}break;case"mo":{const e=t.children[0];if(t.children.length===1&&e instanceof mathMLTree.TextNode){e.text=e.text.replace(/\u2212/,"-").replace(/\u2217/,"*")}else{n=false}break}default:n=false}}else{n=false}}if(n){const e=r.map((e=>e.toText())).join("");r=[new mathMLTree.TextNode(e)]}else if(r.length===1&&["mover","munder"].includes(r[0].type)&&(r[0].children[0].type==="mi"||r[0].children[0].type==="mtext")){r[0].children[0].type="mi";if(e.parentIsSupSub){return new mathMLTree.MathNode("mrow",r)}else{const e=new mathMLTree.MathNode("mo",[makeText("⁡","text")]);return mathMLTree.newDocumentFragment([r[0],e])}}let o;if(n){o=new mathMLTree.MathNode("mi",r);o.setAttribute("mathvariant","normal")}else{o=new mathMLTree.MathNode("mrow",r)}if(!e.parentIsSupSub){const t=new mathMLTree.MathNode("mo",[makeText("⁡","text")]);const r=[o,t];if(e.needsLeadingSpace){const e=new mathMLTree.MathNode("mspace");e.setAttribute("width","0.1667em");r.unshift(e)}if(!e.isFollowedByDelimiter){const e=new mathMLTree.MathNode("mspace");e.setAttribute("width","0.1667em");r.push(e)}return mathMLTree.newDocumentFragment(r)}return o};defineFunction({type:"operatorname",names:["\\operatorname@","\\operatornamewithlimits"],props:{numArgs:1,allowedInArgument:true},handler:({parser:e,funcName:t},r)=>{const n=r[0];const o=e.prevAtomType;const a=e.gullet.future().text;return{type:"operatorname",mode:e.mode,body:ordargument(n),alwaysHandleSupSub:t==="\\operatornamewithlimits",limits:false,parentIsSupSub:false,isFollowedByDelimiter:isDelimiter(a),needsLeadingSpace:o.length>0&&ordTypes.includes(o)}},mathmlBuilder:mathmlBuilder$1});defineMacro("\\operatorname","\\@ifstar\\operatornamewithlimits\\operatorname@");defineFunctionBuilders({type:"ordgroup",mathmlBuilder(e,t){return buildExpressionRow(e.body,t,true)}});defineFunction({type:"phantom",names:["\\phantom"],props:{numArgs:1,allowedInText:true},handler:({parser:e},t)=>{const r=t[0];return{type:"phantom",mode:e.mode,body:ordargument(r)}},mathmlBuilder:(e,t)=>{const r=buildExpression(e.body,t);return new mathMLTree.MathNode("mphantom",r)}});defineFunction({type:"hphantom",names:["\\hphantom"],props:{numArgs:1,allowedInText:true},handler:({parser:e},t)=>{const r=t[0];return{type:"hphantom",mode:e.mode,body:r}},mathmlBuilder:(e,t)=>{const r=buildExpression(ordargument(e.body),t);const n=new mathMLTree.MathNode("mphantom",r);const o=new mathMLTree.MathNode("mpadded",[n]);o.setAttribute("height","0px");o.setAttribute("depth","0px");return o}});defineFunction({type:"vphantom",names:["\\vphantom"],props:{numArgs:1,allowedInText:true},handler:({parser:e},t)=>{const r=t[0];return{type:"vphantom",mode:e.mode,body:r}},mathmlBuilder:(e,t)=>{const r=buildExpression(ordargument(e.body),t);const n=new mathMLTree.MathNode("mphantom",r);const o=new mathMLTree.MathNode("mpadded",[n]);o.setAttribute("width","0px");return o}});defineFunction({type:"pmb",names:["\\pmb"],props:{numArgs:1,allowedInText:true},handler({parser:e},t){return{type:"pmb",mode:e.mode,body:ordargument(t[0])}},mathmlBuilder(e,t){const r=buildExpression(e.body,t);const n=wrapWithMstyle(r);n.setAttribute("style","font-weight:bold");return n}});const sign=e=>e>=0?"+":"-";const mathmlBuilder=(e,t)=>{const r=t.withLevel(StyleLevel.TEXT);const n=new mathMLTree.MathNode("mpadded",[buildGroup$1(e.body,r)]);const o=calculateSize(e.dy,t);n.setAttribute("voffset",o.number+o.unit);const a=Math.abs(o.number);n.setAttribute("height",sign(o.number)+a+o.unit);n.setAttribute("depth",sign(-o.number)+a+o.unit);return n};defineFunction({type:"raise",names:["\\raise","\\lower"],props:{numArgs:2,argTypes:["size","primitive"],primitive:true},handler({parser:e,funcName:t},r){const n=assertNodeType(r[0],"size").value;if(t==="\\lower"){n.number*=-1}const o=r[1];return{type:"raise",mode:e.mode,dy:n,body:o}},mathmlBuilder:mathmlBuilder});defineFunction({type:"raise",names:["\\raisebox"],props:{numArgs:2,argTypes:["size","hbox"],allowedInText:true},handler({parser:e,funcName:t},r){const n=assertNodeType(r[0],"size").value;const o=r[1];return{type:"raise",mode:e.mode,dy:n,body:o}},mathmlBuilder:mathmlBuilder});defineFunction({type:"ref",names:["\\ref","\\eqref"],props:{numArgs:1,argTypes:["raw"]},handler({parser:e,funcName:t},r){return{type:"ref",mode:e.mode,funcName:t,string:r[0].string.replace(invalidIdRegEx,"")}},mathmlBuilder(e,t){const r=e.funcName==="\\ref"?["tml-ref"]:["tml-ref","tml-eqref"];const n=new mathMLTree.MathNode("mtext",[new mathMLTree.TextNode("")],r);n.setAttribute("href","#"+e.string);return n}});defineFunction({type:"internal",names:["\\relax"],props:{numArgs:0,allowedInText:true},handler({parser:e}){return{type:"internal",mode:e.mode}}});defineFunction({type:"rule",names:["\\rule"],props:{numArgs:2,numOptionalArgs:1,argTypes:["size","size","size"]},handler({parser:e},t,r){const n=r[0];const o=assertNodeType(t[0],"size");const a=assertNodeType(t[1],"size");return{type:"rule",mode:e.mode,shift:n&&assertNodeType(n,"size").value,width:o.value,height:a.value}},mathmlBuilder(e,t){const r=calculateSize(e.width,t);const n=calculateSize(e.height,t);const o=e.shift?calculateSize(e.shift,t):{number:0,unit:"em"};const a=t.color&&t.getColor()||"black";const i=new mathMLTree.MathNode("mspace");if(r.number>0&&n.number>0){i.setAttribute("mathbackground",a)}i.setAttribute("width",r.number+r.unit);i.setAttribute("height",n.number+n.unit);if(o.number===0){return i}const s=new mathMLTree.MathNode("mpadded",[i]);if(o.number>=0){s.setAttribute("height","+"+o.number+o.unit)}else{s.setAttribute("height",o.number+o.unit);s.setAttribute("depth","+"+-o.number+o.unit)}s.setAttribute("voffset",o.number+o.unit);return s}});const sizeMap={"\\tiny":.5,"\\sixptsize":.6,"\\Tiny":.6,"\\scriptsize":.7,"\\footnotesize":.8,"\\small":.9,"\\normalsize":1,"\\large":1.2,"\\Large":1.44,"\\LARGE":1.728,"\\huge":2.074,"\\Huge":2.488};defineFunction({type:"sizing",names:["\\tiny","\\sixptsize","\\Tiny","\\scriptsize","\\footnotesize","\\small","\\normalsize","\\large","\\Large","\\LARGE","\\huge","\\Huge"],props:{numArgs:0,allowedInText:true},handler:({breakOnTokenText:e,funcName:t,parser:r},n)=>{if(r.settings.strict&&r.mode==="math"){console.log(`Temml strict-mode warning: Command ${t} is invalid in math mode.`)}const o=r.parseExpression(false,e);return{type:"sizing",mode:r.mode,funcName:t,body:o}},mathmlBuilder:(e,t)=>{const r=t.withFontSize(sizeMap[e.funcName]);const n=buildExpression(e.body,r);const o=wrapWithMstyle(n);const a=(sizeMap[e.funcName]/t.fontSize).toFixed(4);o.setAttribute("mathsize",a+"em");return o}});defineFunction({type:"smash",names:["\\smash"],props:{numArgs:1,numOptionalArgs:1,allowedInText:true},handler:({parser:e},t,r)=>{let n=false;let o=false;const a=r[0]&&assertNodeType(r[0],"ordgroup");if(a){let e="";for(let t=0;t<a.body.length;++t){const r=a.body[t];e=r.text;if(e==="t"){n=true}else if(e==="b"){o=true}else{n=false;o=false;break}}}else{n=true;o=true}const i=t[0];return{type:"smash",mode:e.mode,body:i,smashHeight:n,smashDepth:o}},mathmlBuilder:(e,t)=>{const r=new mathMLTree.MathNode("mpadded",[buildGroup$1(e.body,t)]);if(e.smashHeight){r.setAttribute("height","0px")}if(e.smashDepth){r.setAttribute("depth","0px")}return r}});defineFunction({type:"sqrt",names:["\\sqrt"],props:{numArgs:1,numOptionalArgs:1},handler({parser:e},t,r){const n=r[0];const o=t[0];return{type:"sqrt",mode:e.mode,body:o,index:n}},mathmlBuilder(e,t){const{body:r,index:n}=e;return n?new mathMLTree.MathNode("mroot",[buildGroup$1(r,t),buildGroup$1(n,t.incrementLevel())]):new mathMLTree.MathNode("msqrt",[buildGroup$1(r,t)])}});const styleMap={display:0,text:1,script:2,scriptscript:3};const styleAttributes={display:["0","true"],text:["0","false"],script:["1","false"],scriptscript:["2","false"]};defineFunction({type:"styling",names:["\\displaystyle","\\textstyle","\\scriptstyle","\\scriptscriptstyle"],props:{numArgs:0,allowedInText:true,primitive:true},handler({breakOnTokenText:e,funcName:t,parser:r},n){const o=r.parseExpression(true,e);const a=t.slice(1,t.length-5);return{type:"styling",mode:r.mode,scriptLevel:a,body:o}},mathmlBuilder(e,t){const r=t.withLevel(styleMap[e.scriptLevel]);const n=buildExpression(e.body,r);const o=wrapWithMstyle(n);const a=styleAttributes[e.scriptLevel];o.setAttribute("scriptlevel",a[0]);o.setAttribute("displaystyle",a[1]);return o}});const symbolRegEx=/^m(over|under|underover)$/;defineFunctionBuilders({type:"supsub",mathmlBuilder(e,t){let r=false;let n;let o;let a=false;let i=false;if(e.base&&e.base.type==="horizBrace"){o=!!e.sup;if(o===e.base.isOver){r=true;n=e.base.isOver}}if(e.base&&!e.base.stack&&(e.base.type==="op"||e.base.type==="operatorname")){e.base.parentIsSupSub=true;a=!e.base.symbol;i=e.base.needsLeadingSpace}const s=e.base&&e.base.stack?[buildGroup$1(e.base.body[0],t)]:[buildGroup$1(e.base,t)];const l=t.inSubOrSup();if(e.sub){s.push(buildGroup$1(e.sub,l))}if(e.sup){s.push(buildGroup$1(e.sup,l))}let m;if(r){m=n?"mover":"munder"}else if(!e.sub){const r=e.base;if(r&&r.type==="op"&&r.limits&&(t.level===StyleLevel.DISPLAY||r.alwaysHandleSupSub)){m="mover"}else if(r&&r.type==="operatorname"&&r.alwaysHandleSupSub&&(r.limits||t.level===StyleLevel.DISPLAY)){m="mover"}else{m="msup"}}else if(!e.sup){const r=e.base;if(r&&r.type==="op"&&r.limits&&(t.level===StyleLevel.DISPLAY||r.alwaysHandleSupSub)){m="munder"}else if(r&&r.type==="operatorname"&&r.alwaysHandleSupSub&&(r.limits||t.level===StyleLevel.DISPLAY)){m="munder"}else{m="msub"}}else{const r=e.base;if(r&&(r.type==="op"&&r.limits||r.type==="multiscript")&&(t.level===StyleLevel.DISPLAY||r.alwaysHandleSupSub)){m="munderover"}else if(r&&r.type==="operatorname"&&r.alwaysHandleSupSub&&(t.level===StyleLevel.DISPLAY||r.limits)){m="munderover"}else{m="msubsup"}}let d=new mathMLTree.MathNode(m,s);if(a){const e=new mathMLTree.MathNode("mo",[makeText("⁡","text")]);if(i){const t=new mathMLTree.MathNode("mspace");t.setAttribute("width","0.1667em");d=mathMLTree.newDocumentFragment([t,d,e])}else{d=mathMLTree.newDocumentFragment([d,e])}}else if(symbolRegEx.test(m)){d=new mathMLTree.MathNode("mrow",[d])}return d}});const short=["\\shortmid","\\nshortmid","\\shortparallel","\\nshortparallel","\\smallsetminus"];const arrows=["\\Rsh","\\Lsh","\\restriction"];const isArrow=e=>{if(e.length===1){const t=e.codePointAt(0);return 8591<t&&t<8704}return e.indexOf("arrow")>-1||e.indexOf("harpoon")>-1||arrows.includes(e)};defineFunctionBuilders({type:"atom",mathmlBuilder(e,t){const r=new mathMLTree.MathNode("mo",[makeText(e.text,e.mode)]);if(e.family==="punct"){r.setAttribute("separator","true")}else if(e.family==="open"||e.family==="close"){if(e.family==="open"){r.setAttribute("form","prefix");r.setAttribute("stretchy","false")}else if(e.family==="close"){r.setAttribute("form","postfix");r.setAttribute("stretchy","false")}}else if(e.text==="\\mid"){r.setAttribute("lspace","0.22em");r.setAttribute("rspace","0.22em");r.setAttribute("stretchy","false")}else if(e.family==="rel"&&isArrow(e.text)){r.setAttribute("stretchy","false")}else if(short.includes(e.text)){r.setAttribute("mathsize","70%")}else if(e.text===":"){r.attributes.lspace="0.2222em";r.attributes.rspace="0.2222em"}return r}});const fontMap={mathbf:"bold",mathrm:"normal",textit:"italic",mathit:"italic",mathnormal:"italic",mathbb:"double-struck",mathcal:"script",mathfrak:"fraktur",mathscr:"script",mathsf:"sans-serif",mathtt:"monospace"};const getVariant=function(e,t){if(t.fontFamily==="texttt"){return"monospace"}else if(t.fontFamily==="textsc"){return"normal"}else if(t.fontFamily==="textsf"){if(t.fontShape==="textit"&&t.fontWeight==="textbf"){return"sans-serif-bold-italic"}else if(t.fontShape==="textit"){return"sans-serif-italic"}else if(t.fontWeight==="textbf"){return"sans-serif-bold"}else{return"sans-serif"}}else if(t.fontShape==="textit"&&t.fontWeight==="textbf"){return"bold-italic"}else if(t.fontShape==="textit"){return"italic"}else if(t.fontWeight==="textbf"){return"bold"}const r=t.font;if(!r||r==="mathnormal"){return null}const n=e.mode;switch(r){case"mathit":return"italic";case"mathrm":{const t=e.text.codePointAt(0);return 939<t&&t<975?"italic":"normal"}case"greekItalic":return"italic";case"up@greek":return"normal";case"boldsymbol":case"mathboldsymbol":return"bold-italic";case"mathbf":return"bold";case"mathbb":return"double-struck";case"mathfrak":return"fraktur";case"mathscr":case"mathcal":return"script";case"mathsf":return"sans-serif";case"mathtt":return"monospace"}let o=e.text;if(symbols[n][o]&&symbols[n][o].replace){o=symbols[n][o].replace}return Object.prototype.hasOwnProperty.call(fontMap,r)?fontMap[r]:null};const script=Object.freeze({B:8426,E:8427,F:8427,H:8387,I:8391,L:8390,M:8422,R:8393,e:8394,g:8355,o:8389});const frak=Object.freeze({C:8426,H:8388,I:8392,R:8394,Z:8398});const bbb=Object.freeze({C:8383,H:8389,N:8391,P:8393,Q:8393,R:8395,Z:8394});const bold=Object.freeze({"ϵ":119527,"ϑ":119564,"ϰ":119534,"φ":119577,"ϱ":119535,"ϖ":119563});const boldItalic=Object.freeze({"ϵ":119643,"ϑ":119680,"ϰ":119650,"φ":119693,"ϱ":119651,"ϖ":119679});const boldsf=Object.freeze({"ϵ":119701,"ϑ":119738,"ϰ":119708,"φ":119751,"ϱ":119709,"ϖ":119737});const bisf=Object.freeze({"ϵ":119759,"ϑ":119796,"ϰ":119766,"φ":119809,"ϱ":119767,"ϖ":119795});const offset=Object.freeze({upperCaseLatin:{normal:e=>0,bold:e=>119743,italic:e=>119795,"bold-italic":e=>119847,script:e=>script[e]||119899,"script-bold":e=>119951,fraktur:e=>frak[e]||120003,"fraktur-bold":e=>120107,"double-struck":e=>bbb[e]||120055,"sans-serif":e=>120159,"sans-serif-bold":e=>120211,"sans-serif-italic":e=>120263,"sans-serif-bold-italic":e=>120380,monospace:e=>120367},lowerCaseLatin:{normal:e=>0,bold:e=>119737,italic:e=>e==="h"?8358:119789,"bold-italic":e=>119841,script:e=>script[e]||119893,"script-bold":e=>119945,fraktur:e=>119997,"fraktur-bold":e=>120101,"double-struck":e=>120049,"sans-serif":e=>120153,"sans-serif-bold":e=>120205,"sans-serif-italic":e=>120257,"sans-serif-bold-italic":e=>120309,monospace:e=>120361},upperCaseGreek:{normal:e=>0,bold:e=>e==="∇"?111802:119575,italic:e=>e==="∇"?111860:119633,"bold-italic":e=>e==="∇"?111802:119575,script:e=>0,"script-bold":e=>0,fraktur:e=>0,"fraktur-bold":e=>0,"double-struck":e=>0,"sans-serif":e=>e==="∇"?111976:119749,"sans-serif-bold":e=>e==="∇"?111976:119749,"sans-serif-italic":e=>0,"sans-serif-bold-italic":e=>e==="∇"?112034:119807,monospace:e=>0},lowerCaseGreek:{normal:e=>0,bold:e=>119569,italic:e=>119627,"bold-italic":e=>e==="ϕ"?119678:119685,script:e=>0,"script-bold":e=>0,fraktur:e=>0,"fraktur-bold":e=>0,"double-struck":e=>0,"sans-serif":e=>119743,"sans-serif-bold":e=>119743,"sans-serif-italic":e=>0,"sans-serif-bold-italic":e=>119801,monospace:e=>0},varGreek:{normal:e=>0,bold:e=>bold[e]||-51,italic:e=>0,"bold-italic":e=>boldItalic[e]||58,script:e=>0,"script-bold":e=>0,fraktur:e=>0,"fraktur-bold":e=>0,"double-struck":e=>0,"sans-serif":e=>boldsf[e]||116,"sans-serif-bold":e=>boldsf[e]||116,"sans-serif-italic":e=>0,"sans-serif-bold-italic":e=>bisf[e]||174,monospace:e=>0},numeral:{normal:e=>0,bold:e=>120734,italic:e=>0,"bold-italic":e=>0,script:e=>0,"script-bold":e=>0,fraktur:e=>0,"fraktur-bold":e=>0,"double-struck":e=>120744,"sans-serif":e=>120754,"sans-serif-bold":e=>120764,"sans-serif-italic":e=>0,"sans-serif-bold-italic":e=>0,monospace:e=>120774}});const variantChar=(e,t)=>{const r=e.codePointAt(0);const n=64<r&&r<91?"upperCaseLatin":96<r&&r<123?"lowerCaseLatin":912<r&&r<938||e==="∇"?"upperCaseGreek":944<r&&r<970||e==="ϕ"?"lowerCaseGreek":120545<r&&r<120572||bold[e]?"varGreek":47<r&&r<58?"numeral":"other";return n==="other"?e:String.fromCodePoint(r+offset[n][t](e))};const smallCaps=Object.freeze({a:"ᴀ",b:"ʙ",c:"ᴄ",d:"ᴅ",e:"ᴇ",f:"ꜰ",g:"ɢ",h:"ʜ",i:"ɪ",j:"ᴊ",k:"ᴋ",l:"ʟ",m:"ᴍ",n:"ɴ",o:"ᴏ",p:"ᴘ",q:"ǫ",r:"ʀ",s:"s",t:"ᴛ",u:"ᴜ",v:"ᴠ",w:"ᴡ",x:"x",y:"ʏ",z:"ᴢ"});const numberRegEx$1=/^\d(?:[\d,.]*\d)?$/;const latinRegEx=/[A-Ba-z]/;const italicNumber=(e,t,r)=>{const n=new mathMLTree.MathNode(r,[e]);const o=new mathMLTree.MathNode("mstyle",[n]);o.style["font-style"]="italic";o.style["font-family"]="Cambria, 'Times New Roman', serif";if(t==="bold-italic"){o.style["font-weight"]="bold"}return o};defineFunctionBuilders({type:"mathord",mathmlBuilder(e,t){const r=makeText(e.text,e.mode,t);const n=r.text.codePointAt(0);const o=912<n&&n<938?"normal":"italic";const a=getVariant(e,t)||o;if(a==="script"){r.text=variantChar(r.text,a);return new mathMLTree.MathNode("mi",[r],[t.font])}else if(a!=="italic"){r.text=variantChar(r.text,a)}let i=new mathMLTree.MathNode("mi",[r]);if(a==="normal"){i.setAttribute("mathvariant","normal");if(r.text.length===1){i=new mathMLTree.MathNode("mrow",[i])}}return i}});defineFunctionBuilders({type:"textord",mathmlBuilder(e,t){let r=e.text;const n=r.codePointAt(0);if(t.fontFamily==="textsc"){if(96<n&&n<123){r=smallCaps[r]}}const o=makeText(r,e.mode,t);const a=getVariant(e,t)||"normal";let i;if(numberRegEx$1.test(e.text)){const t=e.mode==="text"?"mtext":"mn";if(a==="italic"||a==="bold-italic"){return italicNumber(o,a,t)}else{if(a!=="normal"){o.text=o.text.split("").map((e=>variantChar(e,a))).join("")}i=new mathMLTree.MathNode(t,[o])}}else if(e.mode==="text"){if(a!=="normal"){o.text=variantChar(o.text,a)}i=new mathMLTree.MathNode("mtext",[o])}else if(e.text==="\\prime"){i=new mathMLTree.MathNode("mo",[o]);i.classes.push("tml-prime")}else{const e=o.text;if(a!=="italic"){o.text=variantChar(o.text,a)}i=new mathMLTree.MathNode("mi",[o]);if(o.text===e&&latinRegEx.test(e)){i.setAttribute("mathvariant","italic")}}return i}});const cssSpace={"\\nobreak":"nobreak","\\allowbreak":"allowbreak"};const regularSpace={" ":{},"\\ ":{},"~":{className:"nobreak"},"\\space":{},"\\nobreakspace":{className:"nobreak"}};defineFunctionBuilders({type:"spacing",mathmlBuilder(e,t){let r;if(Object.prototype.hasOwnProperty.call(regularSpace,e.text)){r=new mathMLTree.MathNode("mtext",[new mathMLTree.TextNode(" ")])}else if(Object.prototype.hasOwnProperty.call(cssSpace,e.text)){r=new mathMLTree.MathNode("mo");if(e.text==="\\nobreak"){r.setAttribute("linebreak","nobreak")}}else{throw new ParseError(`Unknown type of space "${e.text}"`)}return r}});defineFunctionBuilders({type:"tag"});const textFontFamilies={"\\text":undefined,"\\textrm":"textrm","\\textsf":"textsf","\\texttt":"texttt","\\textnormal":"textrm","\\textsc":"textsc"};const textFontWeights={"\\textbf":"textbf","\\textmd":"textmd"};const textFontShapes={"\\textit":"textit","\\textup":"textup"};const styleWithFont=(e,t)=>{const r=e.font;if(!r){return t}else if(textFontFamilies[r]){return t.withTextFontFamily(textFontFamilies[r])}else if(textFontWeights[r]){return t.withTextFontWeight(textFontWeights[r])}else{return t.withTextFontShape(textFontShapes[r])}};defineFunction({type:"text",names:["\\text","\\textrm","\\textsf","\\texttt","\\textnormal","\\textsc","\\textbf","\\textmd","\\textit","\\textup"],props:{numArgs:1,argTypes:["text"],allowedInArgument:true,allowedInText:true},handler({parser:e,funcName:t},r){const n=r[0];return{type:"text",mode:e.mode,body:ordargument(n),font:t}},mathmlBuilder(e,t){const r=styleWithFont(e,t);const n=buildExpressionRow(e.body,r);return consolidateText(n)}});defineFunction({type:"verb",names:["\\verb"],props:{numArgs:0,allowedInText:true},handler(e,t,r){throw new ParseError("\\verb ended by end of line instead of matching delimiter")},mathmlBuilder(e,t){const r=new mathMLTree.TextNode(makeVerb(e));const n=new mathMLTree.MathNode("mtext",[r]);n.setAttribute("mathvariant","monospace");return n}});const makeVerb=e=>e.body.replace(/ /g,e.star?"␣":" ");const functions=_functions;class SourceLocation{constructor(e,t,r){this.lexer=e;this.start=t;this.end=r}static range(e,t){if(!t){return e&&e.loc}else if(!e||!e.loc||!t.loc||e.loc.lexer!==t.loc.lexer){return null}else{return new SourceLocation(e.loc.lexer,e.loc.start,t.loc.end)}}}class Token{constructor(e,t){this.text=e;this.loc=t}range(e,t){return new Token(t,SourceLocation.range(this,e))}}const spaceRegexString="[ \r\n\t]";const controlWordRegexString="\\\\[a-zA-Z@]+";const controlSymbolRegexString="\\\\[^\ud800-\udfff]";const controlWordWhitespaceRegexString=`(${controlWordRegexString})${spaceRegexString}*`;const controlSpaceRegexString="\\\\(\n|[ \r\t]+\n?)[ \r\t]*";const combiningDiacriticalMarkString="[̀-ͯ]";const combiningDiacriticalMarksEndRegex=new RegExp(`${combiningDiacriticalMarkString}+$`);const tokenRegexString=`(${spaceRegexString}+)|`+`${controlSpaceRegexString}|`+"(number"+"|[!-\\[\\]-‧‪-퟿豈-￿]"+`${combiningDiacriticalMarkString}*`+"|[\ud800-\udbff][\udc00-\udfff]"+`${combiningDiacriticalMarkString}*`+"|\\\\verb\\*([^]).*?\\4"+"|\\\\verb([^*a-zA-Z]).*?\\5"+`|${controlWordWhitespaceRegexString}`+`|${controlSymbolRegexString})`;class Lexer{constructor(e,t){this.input=e;this.settings=t;this.tokenRegex=new RegExp(tokenRegexString.replace("number|",t.strict?"":"\\d(?:[\\d,.]*\\d)?|"),"g");this.catcodes={"%":14,"~":13}}setCatcode(e,t){this.catcodes[e]=t}lex(){const e=this.input;const t=this.tokenRegex.lastIndex;if(t===e.length){return new Token("EOF",new SourceLocation(this,t,t))}const r=this.tokenRegex.exec(e);if(r===null||r.index!==t){throw new ParseError(`Unexpected character: '${e[t]}'`,new Token(e[t],new SourceLocation(this,t,t+1)))}const n=r[6]||r[3]||(r[2]?"\\ ":" ");if(this.catcodes[n]===14){const t=e.indexOf("\n",this.tokenRegex.lastIndex);if(t===-1){this.tokenRegex.lastIndex=e.length;if(this.settings.strict){throw new ParseError("% comment has no terminating newline; LaTeX would "+"fail because of commenting the end of math mode")}}else{this.tokenRegex.lastIndex=t+1}return this.lex()}return new Token(n,new SourceLocation(this,t,this.tokenRegex.lastIndex))}}class Namespace{constructor(e={},t={}){this.current=t;this.builtins=e;this.undefStack=[]}beginGroup(){this.undefStack.push({})}endGroup(){if(this.undefStack.length===0){throw new ParseError("Unbalanced namespace destruction: attempt "+"to pop global namespace; please report this as a bug")}const e=this.undefStack.pop();for(const t in e){if(Object.prototype.hasOwnProperty.call(e,t)){if(e[t]===undefined){delete this.current[t]}else{this.current[t]=e[t]}}}}has(e){return Object.prototype.hasOwnProperty.call(this.current,e)||Object.prototype.hasOwnProperty.call(this.builtins,e)}get(e){if(Object.prototype.hasOwnProperty.call(this.current,e)){return this.current[e]}else{return this.builtins[e]}}set(e,t,r=false){if(r){for(let t=0;t<this.undefStack.length;t++){delete this.undefStack[t][e]}if(this.undefStack.length>0){this.undefStack[this.undefStack.length-1][e]=t}}else{const t=this.undefStack[this.undefStack.length-1];if(t&&!Object.prototype.hasOwnProperty.call(t,e)){t[e]=this.current[e]}}this.current[e]=t}}const macros=_macros;defineMacro("\\noexpand",(function(e){const t=e.popToken();if(e.isExpandable(t.text)){t.noexpand=true;t.treatAsRelax=true}return{tokens:[t],numArgs:0}}));defineMacro("\\expandafter",(function(e){const t=e.popToken();e.expandOnce(true);return{tokens:[t],numArgs:0}}));defineMacro("\\@firstoftwo",(function(e){const t=e.consumeArgs(2);return{tokens:t[0],numArgs:0}}));defineMacro("\\@secondoftwo",(function(e){const t=e.consumeArgs(2);return{tokens:t[1],numArgs:0}}));defineMacro("\\@ifnextchar",(function(e){const t=e.consumeArgs(3);e.consumeSpaces();const r=e.future();if(t[0].length===1&&t[0][0].text===r.text){return{tokens:t[1],numArgs:0}}else{return{tokens:t[2],numArgs:0}}}));defineMacro("\\@ifstar","\\@ifnextchar *{\\@firstoftwo{#1}}");defineMacro("\\TextOrMath",(function(e){const t=e.consumeArgs(2);if(e.mode==="text"){return{tokens:t[0],numArgs:0}}else{return{tokens:t[1],numArgs:0}}}));const stringFromArg=e=>{let t="";for(let r=e.length-1;r>-1;r--){t+=e[r].text}return t};const digitToNumber={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,A:10,b:11,B:11,c:12,C:12,d:13,D:13,e:14,E:14,f:15,F:15};const nextCharNumber=e=>{const t=e.future().text;if(t==="EOF"){return[null,""]}return[digitToNumber[t.charAt(0)],t]};const appendCharNumbers=(e,t,r)=>{for(let n=1;n<t.length;n++){const o=digitToNumber[t.charAt(n)];e*=r;e+=o}return e};defineMacro("\\char",(function(e){let t=e.popToken();let r;let n="";if(t.text==="'"){r=8;t=e.popToken()}else if(t.text==='"'){r=16;t=e.popToken()}else if(t.text==="`"){t=e.popToken();if(t.text[0]==="\\"){n=t.text.charCodeAt(1)}else if(t.text==="EOF"){throw new ParseError("\\char` missing argument")}else{n=t.text.charCodeAt(0)}}else{r=10}if(r){let o=t.text;n=digitToNumber[o.charAt(0)];if(n==null||n>=r){throw new ParseError(`Invalid base-${r} digit ${t.text}`)}n=appendCharNumbers(n,o,r);let a;[a,o]=nextCharNumber(e);while(a!=null&&a<r){n*=r;n+=a;n=appendCharNumbers(n,o,r);e.popToken();[a,o]=nextCharNumber(e)}}return`\\@char{${n}}`}));defineMacro("\\surd","\\sqrt{\\vphantom{|}}");defineMacro("\\hbox","\\text{#1}");defineMacro("/","{⁄}");defineMacro("\\long","");defineMacro("\\bgroup","{");defineMacro("\\egroup","}");defineMacro("~","\\nobreakspace");defineMacro("\\lq","`");defineMacro("\\rq","'");defineMacro("\\aa","\\r a");defineMacro("\\Bbbk","\\Bbb{k}");defineMacro("\\mathstrut","\\vphantom{(}");defineMacro("\\underbar","\\underline{\\text{#1}}");defineMacro("\\vdots","{\\varvdots\\rule{0pt}{15pt}}");defineMacro("⋮","\\vdots");defineMacro("\\substack","\\begin{subarray}{c}#1\\end{subarray}");defineMacro("\\boxed","\\fbox{$\\displaystyle{#1}$}");defineMacro("\\iff","\\DOTSB\\;\\Longleftrightarrow\\;");defineMacro("\\implies","\\DOTSB\\;\\Longrightarrow\\;");defineMacro("\\impliedby","\\DOTSB\\;\\Longleftarrow\\;");const dotsByToken={",":"\\dotsc","\\not":"\\dotsb","+":"\\dotsb","=":"\\dotsb","<":"\\dotsb",">":"\\dotsb","-":"\\dotsb","*":"\\dotsb",":":"\\dotsb","\\DOTSB":"\\dotsb","\\coprod":"\\dotsb","\\bigvee":"\\dotsb","\\bigwedge":"\\dotsb","\\biguplus":"\\dotsb","\\bigcap":"\\dotsb","\\bigcup":"\\dotsb","\\prod":"\\dotsb","\\sum":"\\dotsb","\\bigotimes":"\\dotsb","\\bigoplus":"\\dotsb","\\bigodot":"\\dotsb","\\bigsqcap":"\\dotsb","\\bigsqcup":"\\dotsb","\\And":"\\dotsb","\\longrightarrow":"\\dotsb","\\Longrightarrow":"\\dotsb","\\longleftarrow":"\\dotsb","\\Longleftarrow":"\\dotsb","\\longleftrightarrow":"\\dotsb","\\Longleftrightarrow":"\\dotsb","\\mapsto":"\\dotsb","\\longmapsto":"\\dotsb","\\hookrightarrow":"\\dotsb","\\doteq":"\\dotsb","\\mathbin":"\\dotsb","\\mathrel":"\\dotsb","\\relbar":"\\dotsb","\\Relbar":"\\dotsb","\\xrightarrow":"\\dotsb","\\xleftarrow":"\\dotsb","\\DOTSI":"\\dotsi","\\int":"\\dotsi","\\oint":"\\dotsi","\\iint":"\\dotsi","\\iiint":"\\dotsi","\\iiiint":"\\dotsi","\\idotsint":"\\dotsi","\\DOTSX":"\\dotsx"};defineMacro("\\dots",(function(e){let t="\\dotso";const r=e.expandAfterFuture().text;if(r in dotsByToken){t=dotsByToken[r]}else if(r.slice(0,4)==="\\not"){t="\\dotsb"}else if(r in symbols.math){if(["bin","rel"].includes(symbols.math[r].group)){t="\\dotsb"}}return t}));const spaceAfterDots={")":true,"]":true,"\\rbrack":true,"\\}":true,"\\rbrace":true,"\\rangle":true,"\\rceil":true,"\\rfloor":true,"\\rgroup":true,"\\rmoustache":true,"\\right":true,"\\bigr":true,"\\biggr":true,"\\Bigr":true,"\\Biggr":true,$:true,";":true,".":true,",":true};defineMacro("\\dotso",(function(e){const t=e.future().text;if(t in spaceAfterDots){return"\\ldots\\,"}else{return"\\ldots"}}));defineMacro("\\dotsc",(function(e){const t=e.future().text;if(t in spaceAfterDots&&t!==","){return"\\ldots\\,"}else{return"\\ldots"}}));defineMacro("\\cdots",(function(e){const t=e.future().text;if(t in spaceAfterDots){return"\\@cdots\\,"}else{return"\\@cdots"}}));defineMacro("\\dotsb","\\cdots");defineMacro("\\dotsm","\\cdots");defineMacro("\\dotsi","\\!\\cdots");defineMacro("\\idotsint","\\dotsi");defineMacro("\\dotsx","\\ldots\\,");defineMacro("\\DOTSI","\\relax");defineMacro("\\DOTSB","\\relax");defineMacro("\\DOTSX","\\relax");defineMacro("\\tmspace","\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");defineMacro("\\,","{\\tmspace+{3mu}{.1667em}}");defineMacro("\\thinspace","\\,");defineMacro("\\>","\\mskip{4mu}");defineMacro("\\:","{\\tmspace+{4mu}{.2222em}}");defineMacro("\\medspace","\\:");defineMacro("\\;","{\\tmspace+{5mu}{.2777em}}");defineMacro("\\thickspace","\\;");defineMacro("\\!","{\\tmspace-{3mu}{.1667em}}");defineMacro("\\negthinspace","\\!");defineMacro("\\negmedspace","{\\tmspace-{4mu}{.2222em}}");defineMacro("\\negthickspace","{\\tmspace-{5mu}{.277em}}");defineMacro("\\enspace","\\kern.5em ");defineMacro("\\enskip","\\hskip.5em\\relax");defineMacro("\\quad","\\hskip1em\\relax");defineMacro("\\qquad","\\hskip2em\\relax");defineMacro("\\tag","\\@ifstar\\tag@literal\\tag@paren");defineMacro("\\tag@paren","\\tag@literal{({#1})}");defineMacro("\\tag@literal",(e=>{if(e.macros.get("\\df@tag")){throw new ParseError("Multiple \\tag")}return"\\def\\df@tag{\\text{#1}}"}));defineMacro("\\bmod","\\mathbin{\\text{mod}}");defineMacro("\\pod","\\allowbreak"+"\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");defineMacro("\\pmod","\\pod{{\\rm mod}\\mkern6mu#1}");defineMacro("\\mod","\\allowbreak"+"\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}"+"{\\rm mod}\\,\\,#1");defineMacro("\\newline","\\\\\\relax");defineMacro("\\TeX","\\textrm{T}\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125em\\textrm{X}");defineMacro("\\LaTeX","\\textrm{L}\\kern-.35em\\raisebox{0.2em}{\\scriptstyle A}\\kern-.15em\\TeX");defineMacro("\\Temml","\\textrm{T}\\kern-0.2em\\lower{0.2em}\\textrm{E}\\kern-0.08em{\\textrm{M}\\kern-0.08em\\raise{0.2em}\\textrm{M}\\kern-0.08em\\textrm{L}}");defineMacro("\\hspace","\\@ifstar\\@hspacer\\@hspace");defineMacro("\\@hspace","\\hskip #1\\relax");defineMacro("\\@hspacer","\\rule{0pt}{0pt}\\hskip #1\\relax");defineMacro("\\colon",`\\mathpunct{\\char"3a}`);defineMacro("\\prescript","\\pres@cript{_{#1}^{#2}}{}{#3}");defineMacro("\\ordinarycolon",`\\char"3a`);defineMacro("\\vcentcolon","\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}}");defineMacro("\\coloneq",'\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2212}');defineMacro("\\Coloneq",'\\mathrel{\\char"2237\\char"2212}');defineMacro("\\Eqqcolon",'\\mathrel{\\char"3d\\char"2237}');defineMacro("\\Eqcolon",'\\mathrel{\\char"2212\\char"2237}');defineMacro("\\colonapprox",'\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2248}');defineMacro("\\Colonapprox",'\\mathrel{\\char"2237\\char"2248}');defineMacro("\\colonsim",'\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');defineMacro("\\Colonsim",'\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');defineMacro("\\ratio","\\vcentcolon");defineMacro("\\coloncolon","\\dblcolon");defineMacro("\\colonequals","\\coloneqq");defineMacro("\\coloncolonequals","\\Coloneqq");defineMacro("\\equalscolon","\\eqqcolon");defineMacro("\\equalscoloncolon","\\Eqqcolon");defineMacro("\\colonminus","\\coloneq");defineMacro("\\coloncolonminus","\\Coloneq");defineMacro("\\minuscolon","\\eqcolon");defineMacro("\\minuscoloncolon","\\Eqcolon");defineMacro("\\coloncolonapprox","\\Colonapprox");defineMacro("\\coloncolonsim","\\Colonsim");defineMacro("\\notni","\\mathrel{\\char`∌}");defineMacro("\\limsup","\\DOTSB\\operatorname*{lim\\,sup}");defineMacro("\\liminf","\\DOTSB\\operatorname*{lim\\,inf}");defineMacro("\\injlim","\\DOTSB\\operatorname*{inj\\,lim}");defineMacro("\\projlim","\\DOTSB\\operatorname*{proj\\,lim}");defineMacro("\\varlimsup","\\DOTSB\\operatorname*{\\overline{\\text{lim}}}");defineMacro("\\varliminf","\\DOTSB\\operatorname*{\\underline{\\text{lim}}}");defineMacro("\\varinjlim","\\DOTSB\\operatorname*{\\underrightarrow{\\text{lim}}}");defineMacro("\\varprojlim","\\DOTSB\\operatorname*{\\underleftarrow{\\text{lim}}}");defineMacro("\\centerdot","{\\medspace\\rule{0.167em}{0.189em}\\medspace}");defineMacro("\\argmin","\\DOTSB\\operatorname*{arg\\,min}");defineMacro("\\argmax","\\DOTSB\\operatorname*{arg\\,max}");defineMacro("\\plim","\\DOTSB\\operatorname*{plim}");defineMacro("\\bra","\\mathinner{\\langle{#1}|}");defineMacro("\\ket","\\mathinner{|{#1}\\rangle}");defineMacro("\\braket","\\mathinner{\\langle{#1}\\rangle}");defineMacro("\\Bra","\\left\\langle#1\\right|");defineMacro("\\Ket","\\left|#1\\right\\rangle");const braketHelper=e=>t=>{const r=t.consumeArg().tokens;const n=t.consumeArg().tokens;const o=t.consumeArg().tokens;const a=t.consumeArg().tokens;const i=t.macros.get("|");const s=t.macros.get("\\|");t.macros.beginGroup();const l=t=>r=>{if(e){r.macros.set("|",i);if(o.length){r.macros.set("\\|",s)}}let a=t;if(!t&&o.length){const e=r.future();if(e.text==="|"){r.popToken();a=true}}return{tokens:a?o:n,numArgs:0}};t.macros.set("|",l(false));if(o.length){t.macros.set("\\|",l(true))}const m=t.consumeArg().tokens;const d=t.expandTokens([...a,...m,...r]);t.macros.endGroup();return{tokens:d.reverse(),numArgs:0}};defineMacro("\\bra@ket",braketHelper(false));defineMacro("\\bra@set",braketHelper(true));defineMacro("\\Braket","\\bra@ket{\\left\\langle}"+"{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");defineMacro("\\Set","\\bra@set{\\left\\{\\:}"+"{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");defineMacro("\\set","\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");defineMacro("\\angln","{\\angl n}");defineMacro("\\odv","\\@ifstar\\odv@next\\odv@numerator");defineMacro("\\odv@numerator","\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}");defineMacro("\\odv@next","\\frac{\\mathrm{d}}{\\mathrm{d}#2}#1");defineMacro("\\pdv","\\@ifstar\\pdv@next\\pdv@numerator");const pdvHelper=e=>{const t=e[0][0].text;const r=stringFromArg(e[1]).split(",");const n=String(r.length);const o=n==="1"?"\\partial":`\\partial^${n}`;let a="";r.map((e=>{a+="\\partial "+e.trim()+"\\,"}));return[t,o,a.replace(/\\,$/,"")]};defineMacro("\\pdv@numerator",(function(e){const[t,r,n]=pdvHelper(e.consumeArgs(2));return`\\frac{${r} ${t}}{${n}}`}));defineMacro("\\pdv@next",(function(e){const[t,r,n]=pdvHelper(e.consumeArgs(2));return`\\frac{${r}}{${n}} ${t}`}));defineMacro("\\upalpha","\\up@greek{\\alpha}");defineMacro("\\upbeta","\\up@greek{\\beta}");defineMacro("\\upgamma","\\up@greek{\\gamma}");defineMacro("\\updelta","\\up@greek{\\delta}");defineMacro("\\upepsilon","\\up@greek{\\epsilon}");defineMacro("\\upzeta","\\up@greek{\\zeta}");defineMacro("\\upeta","\\up@greek{\\eta}");defineMacro("\\uptheta","\\up@greek{\\theta}");defineMacro("\\upiota","\\up@greek{\\iota}");defineMacro("\\upkappa","\\up@greek{\\kappa}");defineMacro("\\uplambda","\\up@greek{\\lambda}");defineMacro("\\upmu","\\up@greek{\\mu}");defineMacro("\\upnu","\\up@greek{\\nu}");defineMacro("\\upxi","\\up@greek{\\xi}");defineMacro("\\upomicron","\\up@greek{\\omicron}");defineMacro("\\uppi","\\up@greek{\\pi}");defineMacro("\\upalpha","\\up@greek{\\alpha}");defineMacro("\\uprho","\\up@greek{\\rho}");defineMacro("\\upsigma","\\up@greek{\\sigma}");defineMacro("\\uptau","\\up@greek{\\tau}");defineMacro("\\upupsilon","\\up@greek{\\upsilon}");defineMacro("\\upphi","\\up@greek{\\phi}");defineMacro("\\upchi","\\up@greek{\\chi}");defineMacro("\\uppsi","\\up@greek{\\psi}");defineMacro("\\upomega","\\up@greek{\\omega}");defineMacro("\\invamp",'\\mathbin{\\char"214b}');defineMacro("\\parr",'\\mathbin{\\char"214b}');defineMacro("\\with",'\\mathbin{\\char"26}');defineMacro("\\multimapinv",'\\mathrel{\\char"27dc}');defineMacro("\\multimapboth",'\\mathrel{\\char"29df}');defineMacro("\\scoh",'{\\mkern5mu\\char"2322\\mkern5mu}');defineMacro("\\sincoh",'{\\mkern5mu\\char"2323\\mkern5mu}');defineMacro("\\coh",`{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2322}}}\n{\\smash{\\lower4mu{\\char"2323}}}\\mkern5mu}`);defineMacro("\\incoh",`{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2323}}}\n{\\smash{\\lower4mu{\\char"2322}}}\\mkern5mu}`);defineMacro("\\standardstate","\\text{\\tiny\\char`⦵}");defineMacro("\\ce",(function(e){return chemParse(e.consumeArgs(1)[0],"ce")}));defineMacro("\\pu",(function(e){return chemParse(e.consumeArgs(1)[0],"pu")}));defineMacro("\\uniDash",`{\\rule{0.672em}{0.06em}}`);defineMacro("\\triDash",`{\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}}`);defineMacro("\\tripleDash",`\\kern0.075em\\raise0.25em{\\triDash}\\kern0.075em`);defineMacro("\\tripleDashOverLine",`\\kern0.075em\\mathrlap{\\raise0.125em{\\uniDash}}\\raise0.34em{\\triDash}\\kern0.075em`);defineMacro("\\tripleDashOverDoubleLine",`\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\triDash}}\\raise0.27em{\\uniDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`);defineMacro("\\tripleDashBetweenDoubleLine",`\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\uniDash}}\\raise0.27em{\\triDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`);var chemParse=function(e,t){var r="";var n=e.length&&e[e.length-1].loc.start;for(var o=e.length-1;o>=0;o--){if(e[o].loc.start>n){r+=" ";n=e[o].loc.start}r+=e[o].text;n+=e[o].text.length}var a=texify.go(mhchemParser.go(r,t));return a};var mhchemParser={go:function(e,t){if(!e){return[]}if(t===undefined){t="ce"}var r="0";var n={};n["parenthesisLevel"]=0;e=e.replace(/\n/g," ");e=e.replace(/[\u2212\u2013\u2014\u2010]/g,"-");e=e.replace(/[\u2026]/g,"...");var o;var a=10;var i=[];while(true){if(o!==e){a=10;o=e}else{a--}var s=mhchemParser.stateMachines[t];var l=s.transitions[r]||s.transitions["*"];e:for(var m=0;m<l.length;m++){var d=mhchemParser.patterns.match_(l[m].pattern,e);if(d){var c=l[m].task;for(var u=0;u<c.action_.length;u++){var h;if(s.actions[c.action_[u].type_]){h=s.actions[c.action_[u].type_](n,d.match_,c.action_[u].option)}else if(mhchemParser.actions[c.action_[u].type_]){h=mhchemParser.actions[c.action_[u].type_](n,d.match_,c.action_[u].option)}else{throw["MhchemBugA","mhchem bug A. Please report. ("+c.action_[u].type_+")"]}mhchemParser.concatArray(i,h)}r=c.nextState||r;if(e.length>0){if(!c.revisit){e=d.remainder}if(!c.toContinue){break e}}else{return i}}}if(a<=0){throw["MhchemBugU","mhchem bug U. Please report."]}}},concatArray:function(e,t){if(t){if(Array.isArray(t)){for(var r=0;r<t.length;r++){e.push(t[r])}}else{e.push(t)}}},patterns:{patterns:{empty:/^$/,else:/^./,else2:/^./,space:/^\s/,"space A":/^\s(?=[A-Z\\$])/,space$:/^\s$/,"a-z":/^[a-z]/,x:/^x/,x$:/^x$/,i$:/^i$/,letters:/^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,"\\greek":/^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,"one lowercase latin letter $":/^(?:([a-z])(?:$|[^a-zA-Z]))$/,"$one lowercase latin letter$ $":/^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,"one lowercase greek letter $":/^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,digits:/^[0-9]+/,"-9.,9":/^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,"-9.,9 no missing 0":/^[+\-]?[0-9]+(?:[.,][0-9]+)?/,"(-)(9.,9)(e)(99)":function(e){var t=e.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);if(t&&t[0]){return{match_:t.splice(1),remainder:e.substr(t[0].length)}}return null},"(-)(9)^(-9)":function(e){var t=e.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);if(t&&t[0]){return{match_:t.splice(1),remainder:e.substr(t[0].length)}}return null},"state of aggregation $":function(e){var t=mhchemParser.patterns.findObserveGroups(e,"",/^\([a-z]{1,3}(?=[\),])/,")","");if(t&&t.remainder.match(/^($|[\s,;\)\]\}])/)){return t}var r=e.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);if(r){return{match_:r[0],remainder:e.substr(r[0].length)}}return null},"_{(state of aggregation)}$":/^_\{(\([a-z]{1,3}\))\}/,"{[(":/^(?:\\\{|\[|\()/,")]}":/^(?:\)|\]|\\\})/,", ":/^[,;]\s*/,",":/^[,;]/,".":/^[.]/,". ":/^([.\u22C5\u00B7\u2022])\s*/,"...":/^\.\.\.(?=$|[^.])/,"* ":/^([*])\s*/,"^{(...)}":function(e){return mhchemParser.patterns.findObserveGroups(e,"^{","","","}")},"^($...$)":function(e){return mhchemParser.patterns.findObserveGroups(e,"^","$","$","")},"^a":/^\^([0-9]+|[^\\_])/,"^\\x{}{}":function(e){return mhchemParser.patterns.findObserveGroups(e,"^",/^\\[a-zA-Z]+\{/,"}","","","{","}","",true)},"^\\x{}":function(e){return mhchemParser.patterns.findObserveGroups(e,"^",/^\\[a-zA-Z]+\{/,"}","")},"^\\x":/^\^(\\[a-zA-Z]+)\s*/,"^(-1)":/^\^(-?\d+)/,"'":/^'/,"_{(...)}":function(e){return mhchemParser.patterns.findObserveGroups(e,"_{","","","}")},"_($...$)":function(e){return mhchemParser.patterns.findObserveGroups(e,"_","$","$","")},_9:/^_([+\-]?[0-9]+|[^\\])/,"_\\x{}{}":function(e){return mhchemParser.patterns.findObserveGroups(e,"_",/^\\[a-zA-Z]+\{/,"}","","","{","}","",true)},"_\\x{}":function(e){return mhchemParser.patterns.findObserveGroups(e,"_",/^\\[a-zA-Z]+\{/,"}","")},"_\\x":/^_(\\[a-zA-Z]+)\s*/,"^_":/^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,"{}":/^\{\}/,"{...}":function(e){return mhchemParser.patterns.findObserveGroups(e,"","{","}","")},"{(...)}":function(e){return mhchemParser.patterns.findObserveGroups(e,"{","","","}")},"$...$":function(e){return mhchemParser.patterns.findObserveGroups(e,"","$","$","")},"${(...)}$":function(e){return mhchemParser.patterns.findObserveGroups(e,"${","","","}$")},"$(...)$":function(e){return mhchemParser.patterns.findObserveGroups(e,"$","","","$")},"=<>":/^[=<>]/,"#":/^[#\u2261]/,"+":/^\+/,"-$":/^-(?=[\s_},;\]/]|$|\([a-z]+\))/,"-9":/^-(?=[0-9])/,"- orbital overlap":/^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,"-":/^-/,"pm-operator":/^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,operator:/^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,arrowUpDown:/^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,"\\bond{(...)}":function(e){return mhchemParser.patterns.findObserveGroups(e,"\\bond{","","","}")},"->":/^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,CMT:/^[CMT](?=\[)/,"[(...)]":function(e){return mhchemParser.patterns.findObserveGroups(e,"[","","","]")},"1st-level escape":/^(&|\\\\|\\hline)\s*/,"\\,":/^(?:\\[,\ ;:])/,"\\x{}{}":function(e){return mhchemParser.patterns.findObserveGroups(e,"",/^\\[a-zA-Z]+\{/,"}","","","{","}","",true)},"\\x{}":function(e){return mhchemParser.patterns.findObserveGroups(e,"",/^\\[a-zA-Z]+\{/,"}","")},"\\ca":/^\\ca(?:\s+|(?![a-zA-Z]))/,"\\x":/^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,orbital:/^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,others:/^[\/~|]/,"\\frac{(...)}":function(e){return mhchemParser.patterns.findObserveGroups(e,"\\frac{","","","}","{","","","}")},"\\overset{(...)}":function(e){return mhchemParser.patterns.findObserveGroups(e,"\\overset{","","","}","{","","","}")},"\\underset{(...)}":function(e){return mhchemParser.patterns.findObserveGroups(e,"\\underset{","","","}","{","","","}")},"\\underbrace{(...)}":function(e){return mhchemParser.patterns.findObserveGroups(e,"\\underbrace{","","","}_","{","","","}")},"\\color{(...)}0":function(e){return mhchemParser.patterns.findObserveGroups(e,"\\color{","","","}")},"\\color{(...)}{(...)}1":function(e){return mhchemParser.patterns.findObserveGroups(e,"\\color{","","","}","{","","","}")},"\\color(...){(...)}2":function(e){return mhchemParser.patterns.findObserveGroups(e,"\\color","\\","",/^(?=\{)/,"{","","","}")},"\\ce{(...)}":function(e){return mhchemParser.patterns.findObserveGroups(e,"\\ce{","","","}")},oxidation$:/^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,"d-oxidation$":/^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,"roman numeral":/^[IVX]+/,"1/2$":/^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,amount:function(e){var t;t=e.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/);if(t){return{match_:t[0],remainder:e.substr(t[0].length)}}var r=mhchemParser.patterns.findObserveGroups(e,"","$","$","");if(r){t=r.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/);if(t){return{match_:t[0],remainder:e.substr(t[0].length)}}}return null},amount2:function(e){return this["amount"](e)},"(KV letters),":/^(?:[A-Z][a-z]{0,2}|i)(?=,)/,formula$:function(e){if(e.match(/^\([a-z]+\)$/)){return null}var t=e.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);if(t){return{match_:t[0],remainder:e.substr(t[0].length)}}return null},uprightEntities:/^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,"/":/^\s*(\/)\s*/,"//":/^\s*(\/\/)\s*/,"*":/^\s*[*.]\s*/},findObserveGroups:function(e,t,r,n,o,a,i,s,l,m){var d=function(e,t){if(typeof t==="string"){if(e.indexOf(t)!==0){return null}return t}else{var r=e.match(t);if(!r){return null}return r[0]}};var c=function(e,t,r){var n=0;while(t<e.length){var o=e.charAt(t);var a=d(e.substr(t),r);if(a!==null&&n===0){return{endMatchBegin:t,endMatchEnd:t+a.length}}else if(o==="{"){n++}else if(o==="}"){if(n===0){throw["ExtraCloseMissingOpen","Extra close brace or missing open brace"]}else{n--}}t++}if(n>0){return null}return null};var u=d(e,t);if(u===null){return null}e=e.substr(u.length);u=d(e,r);if(u===null){return null}var h=c(e,u.length,n||o);if(h===null){return null}var p=e.substring(0,n?h.endMatchEnd:h.endMatchBegin);if(!(a||i)){return{match_:p,remainder:e.substr(h.endMatchEnd)}}else{var f=this.findObserveGroups(e.substr(h.endMatchEnd),a,i,s,l);if(f===null){return null}var b=[p,f.match_];return{match_:m?b.join(""):b,remainder:f.remainder}}},match_:function(e,t){var r=mhchemParser.patterns.patterns[e];if(r===undefined){throw["MhchemBugP","mhchem bug P. Please report. ("+e+")"]}else if(typeof r==="function"){return mhchemParser.patterns.patterns[e](t)}else{var n=t.match(r);if(n){var o;if(n[2]){o=[n[1],n[2]]}else if(n[1]){o=n[1]}else{o=n[0]}return{match_:o,remainder:t.substr(n[0].length)}}return null}}},actions:{"a=":function(e,t){e.a=(e.a||"")+t},"b=":function(e,t){e.b=(e.b||"")+t},"p=":function(e,t){e.p=(e.p||"")+t},"o=":function(e,t){e.o=(e.o||"")+t},"q=":function(e,t){e.q=(e.q||"")+t},"d=":function(e,t){e.d=(e.d||"")+t},"rm=":function(e,t){e.rm=(e.rm||"")+t},"text=":function(e,t){e.text_=(e.text_||"")+t},insert:function(e,t,r){return{type_:r}},"insert+p1":function(e,t,r){return{type_:r,p1:t}},"insert+p1+p2":function(e,t,r){return{type_:r,p1:t[0],p2:t[1]}},copy:function(e,t){return t},rm:function(e,t){return{type_:"rm",p1:t||""}},text:function(e,t){return mhchemParser.go(t,"text")},"{text}":function(e,t){var r=["{"];mhchemParser.concatArray(r,mhchemParser.go(t,"text"));r.push("}");return r},"tex-math":function(e,t){return mhchemParser.go(t,"tex-math")},"tex-math tight":function(e,t){return mhchemParser.go(t,"tex-math tight")},bond:function(e,t,r){return{type_:"bond",kind_:r||t}},"color0-output":function(e,t){return{type_:"color0",color:t[0]}},ce:function(e,t){return mhchemParser.go(t)},"1/2":function(e,t){var r=[];if(t.match(/^[+\-]/)){r.push(t.substr(0,1));t=t.substr(1)}var n=t.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);n[1]=n[1].replace(/\$/g,"");r.push({type_:"frac",p1:n[1],p2:n[2]});if(n[3]){n[3]=n[3].replace(/\$/g,"");r.push({type_:"tex-math",p1:n[3]})}return r},"9,9":function(e,t){return mhchemParser.go(t,"9,9")}},createTransitions:function(e){var t,r;var n;var o;var a={};for(t in e){for(r in e[t]){n=r.split("|");e[t][r].stateArray=n;for(o=0;o<n.length;o++){a[n[o]]=[]}}}for(t in e){for(r in e[t]){n=e[t][r].stateArray||[];for(o=0;o<n.length;o++){var i=e[t][r];if(i.action_){i.action_=[].concat(i.action_);for(var s=0;s<i.action_.length;s++){if(typeof i.action_[s]==="string"){i.action_[s]={type_:i.action_[s]}}}}else{i.action_=[]}var l=t.split("|");for(var m=0;m<l.length;m++){if(n[o]==="*"){for(var d in a){a[d].push({pattern:l[m],task:i})}}else{a[n[o]].push({pattern:l[m],task:i})}}}}}return a},stateMachines:{}};mhchemParser.stateMachines={ce:{transitions:mhchemParser.createTransitions({empty:{"*":{action_:"output"}},else:{"0|1|2":{action_:"beginsWithBond=false",revisit:true,toContinue:true}},oxidation$:{0:{action_:"oxidation-output"}},CMT:{r:{action_:"rdt=",nextState:"rt"},rd:{action_:"rqt=",nextState:"rdt"}},arrowUpDown:{"0|1|2|as":{action_:["sb=false","output","operator"],nextState:"1"}},uprightEntities:{"0|1|2":{action_:["o=","output"],nextState:"1"}},orbital:{"0|1|2|3":{action_:"o=",nextState:"o"}},"->":{"0|1|2|3":{action_:"r=",nextState:"r"},"a|as":{action_:["output","r="],nextState:"r"},"*":{action_:["output","r="],nextState:"r"}},"+":{o:{action_:"d= kv",nextState:"d"},"d|D":{action_:"d=",nextState:"d"},q:{action_:"d=",nextState:"qd"},"qd|qD":{action_:"d=",nextState:"qd"},dq:{action_:["output","d="],nextState:"d"},3:{action_:["sb=false","output","operator"],nextState:"0"}},amount:{"0|2":{action_:"a=",nextState:"a"}},"pm-operator":{"0|1|2|a|as":{action_:["sb=false","output",{type_:"operator",option:"\\pm"}],nextState:"0"}},operator:{"0|1|2|a|as":{action_:["sb=false","output","operator"],nextState:"0"}},"-$":{"o|q":{action_:["charge or bond","output"],nextState:"qd"},d:{action_:"d=",nextState:"d"},D:{action_:["output",{type_:"bond",option:"-"}],nextState:"3"},q:{action_:"d=",nextState:"qd"},qd:{action_:"d=",nextState:"qd"},"qD|dq":{action_:["output",{type_:"bond",option:"-"}],nextState:"3"}},"-9":{"3|o":{action_:["output",{type_:"insert",option:"hyphen"}],nextState:"3"}},"- orbital overlap":{o:{action_:["output",{type_:"insert",option:"hyphen"}],nextState:"2"},d:{action_:["output",{type_:"insert",option:"hyphen"}],nextState:"2"}},"-":{"0|1|2":{action_:[{type_:"output",option:1},"beginsWithBond=true",{type_:"bond",option:"-"}],nextState:"3"},3:{action_:{type_:"bond",option:"-"}},a:{action_:["output",{type_:"insert",option:"hyphen"}],nextState:"2"},as:{action_:[{type_:"output",option:2},{type_:"bond",option:"-"}],nextState:"3"},b:{action_:"b="},o:{action_:{type_:"- after o/d",option:false},nextState:"2"},q:{action_:{type_:"- after o/d",option:false},nextState:"2"},"d|qd|dq":{action_:{type_:"- after o/d",option:true},nextState:"2"},"D|qD|p":{action_:["output",{type_:"bond",option:"-"}],nextState:"3"}},amount2:{"1|3":{action_:"a=",nextState:"a"}},letters:{"0|1|2|3|a|as|b|p|bp|o":{action_:"o=",nextState:"o"},"q|dq":{action_:["output","o="],nextState:"o"},"d|D|qd|qD":{action_:"o after d",nextState:"o"}},digits:{o:{action_:"q=",nextState:"q"},"d|D":{action_:"q=",nextState:"dq"},q:{action_:["output","o="],nextState:"o"},a:{action_:"o=",nextState:"o"}},"space A":{"b|p|bp":{}},space:{a:{nextState:"as"},0:{action_:"sb=false"},"1|2":{action_:"sb=true"},"r|rt|rd|rdt|rdq":{action_:"output",nextState:"0"},"*":{action_:["output","sb=true"],nextState:"1"}},"1st-level escape":{"1|2":{action_:["output",{type_:"insert+p1",option:"1st-level escape"}]},"*":{action_:["output",{type_:"insert+p1",option:"1st-level escape"}],nextState:"0"}},"[(...)]":{"r|rt":{action_:"rd=",nextState:"rd"},"rd|rdt":{action_:"rq=",nextState:"rdq"}},"...":{"o|d|D|dq|qd|qD":{action_:["output",{type_:"bond",option:"..."}],nextState:"3"},"*":{action_:[{type_:"output",option:1},{type_:"insert",option:"ellipsis"}],nextState:"1"}},". |* ":{"*":{action_:["output",{type_:"insert",option:"addition compound"}],nextState:"1"}},"state of aggregation $":{"*":{action_:["output","state of aggregation"],nextState:"1"}},"{[(":{"a|as|o":{action_:["o=","output","parenthesisLevel++"],nextState:"2"},"0|1|2|3":{action_:["o=","output","parenthesisLevel++"],nextState:"2"},"*":{action_:["output","o=","output","parenthesisLevel++"],nextState:"2"}},")]}":{"0|1|2|3|b|p|bp|o":{action_:["o=","parenthesisLevel--"],nextState:"o"},"a|as|d|D|q|qd|qD|dq":{action_:["output","o=","parenthesisLevel--"],nextState:"o"}},", ":{"*":{action_:["output","comma"],nextState:"0"}},"^_":{"*":{}},"^{(...)}|^($...$)":{"0|1|2|as":{action_:"b=",nextState:"b"},p:{action_:"b=",nextState:"bp"},"3|o":{action_:"d= kv",nextState:"D"},q:{action_:"d=",nextState:"qD"},"d|D|qd|qD|dq":{action_:["output","d="],nextState:"D"}},"^a|^\\x{}{}|^\\x{}|^\\x|'":{"0|1|2|as":{action_:"b=",nextState:"b"},p:{action_:"b=",nextState:"bp"},"3|o":{action_:"d= kv",nextState:"d"},q:{action_:"d=",nextState:"qd"},"d|qd|D|qD":{action_:"d="},dq:{action_:["output","d="],nextState:"d"}},"_{(state of aggregation)}$":{"d|D|q|qd|qD|dq":{action_:["output","q="],nextState:"q"}},"_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x":{"0|1|2|as":{action_:"p=",nextState:"p"},b:{action_:"p=",nextState:"bp"},"3|o":{action_:"q=",nextState:"q"},"d|D":{action_:"q=",nextState:"dq"},"q|qd|qD|dq":{action_:["output","q="],nextState:"q"}},"=<>":{"0|1|2|3|a|as|o|q|d|D|qd|qD|dq":{action_:[{type_:"output",option:2},"bond"],nextState:"3"}},"#":{"0|1|2|3|a|as|o":{action_:[{type_:"output",option:2},{type_:"bond",option:"#"}],nextState:"3"}},"{}":{"*":{action_:{type_:"output",option:1},nextState:"1"}},"{...}":{"0|1|2|3|a|as|b|p|bp":{action_:"o=",nextState:"o"},"o|d|D|q|qd|qD|dq":{action_:["output","o="],nextState:"o"}},"$...$":{a:{action_:"a="},"0|1|2|3|as|b|p|bp|o":{action_:"o=",nextState:"o"},"as|o":{action_:"o="},"q|d|D|qd|qD|dq":{action_:["output","o="],nextState:"o"}},"\\bond{(...)}":{"*":{action_:[{type_:"output",option:2},"bond"],nextState:"3"}},"\\frac{(...)}":{"*":{action_:[{type_:"output",option:1},"frac-output"],nextState:"3"}},"\\overset{(...)}":{"*":{action_:[{type_:"output",option:2},"overset-output"],nextState:"3"}},"\\underset{(...)}":{"*":{action_:[{type_:"output",option:2},"underset-output"],nextState:"3"}},"\\underbrace{(...)}":{"*":{action_:[{type_:"output",option:2},"underbrace-output"],nextState:"3"}},"\\color{(...)}{(...)}1|\\color(...){(...)}2":{"*":{action_:[{type_:"output",option:2},"color-output"],nextState:"3"}},"\\color{(...)}0":{"*":{action_:[{type_:"output",option:2},"color0-output"]}},"\\ce{(...)}":{"*":{action_:[{type_:"output",option:2},"ce"],nextState:"3"}},"\\,":{"*":{action_:[{type_:"output",option:1},"copy"],nextState:"1"}},"\\x{}{}|\\x{}|\\x":{"0|1|2|3|a|as|b|p|bp|o|c0":{action_:["o=","output"],nextState:"3"},"*":{action_:["output","o=","output"],nextState:"3"}},others:{"*":{action_:[{type_:"output",option:1},"copy"],nextState:"3"}},else2:{a:{action_:"a to o",nextState:"o",revisit:true},as:{action_:["output","sb=true"],nextState:"1",revisit:true},"r|rt|rd|rdt|rdq":{action_:["output"],nextState:"0",revisit:true},"*":{action_:["output","copy"],nextState:"3"}}}),actions:{"o after d":function(e,t){var r;if((e.d||"").match(/^[0-9]+$/)){var n=e.d;e.d=undefined;r=this["output"](e);e.b=n}else{r=this["output"](e)}mhchemParser.actions["o="](e,t);return r},"d= kv":function(e,t){e.d=t;e.dType="kv"},"charge or bond":function(e,t){if(e["beginsWithBond"]){var r=[];mhchemParser.concatArray(r,this["output"](e));mhchemParser.concatArray(r,mhchemParser.actions["bond"](e,t,"-"));return r}else{e.d=t}},"- after o/d":function(e,t,r){var n=mhchemParser.patterns.match_("orbital",e.o||"");var o=mhchemParser.patterns.match_("one lowercase greek letter $",e.o||"");var a=mhchemParser.patterns.match_("one lowercase latin letter $",e.o||"");var i=mhchemParser.patterns.match_("$one lowercase latin letter$ $",e.o||"");var s=t==="-"&&(n&&n.remainder===""||o||a||i);if(s&&!e.a&&!e.b&&!e.p&&!e.d&&!e.q&&!n&&a){e.o="$"+e.o+"$"}var l=[];if(s){mhchemParser.concatArray(l,this["output"](e));l.push({type_:"hyphen"})}else{n=mhchemParser.patterns.match_("digits",e.d||"");if(r&&n&&n.remainder===""){mhchemParser.concatArray(l,mhchemParser.actions["d="](e,t));mhchemParser.concatArray(l,this["output"](e))}else{mhchemParser.concatArray(l,this["output"](e));mhchemParser.concatArray(l,mhchemParser.actions["bond"](e,t,"-"))}}return l},"a to o":function(e){e.o=e.a;e.a=undefined},"sb=true":function(e){e.sb=true},"sb=false":function(e){e.sb=false},"beginsWithBond=true":function(e){e["beginsWithBond"]=true},"beginsWithBond=false":function(e){e["beginsWithBond"]=false},"parenthesisLevel++":function(e){e["parenthesisLevel"]++},"parenthesisLevel--":function(e){e["parenthesisLevel"]--},"state of aggregation":function(e,t){return{type_:"state of aggregation",p1:mhchemParser.go(t,"o")}},comma:function(e,t){var r=t.replace(/\s*$/,"");var n=r!==t;if(n&&e["parenthesisLevel"]===0){return{type_:"comma enumeration L",p1:r}}else{return{type_:"comma enumeration M",p1:r}}},output:function(e,t,r){var n;if(!e.r){n=[];if(!e.a&&!e.b&&!e.p&&!e.o&&!e.q&&!e.d&&!r){}else{if(e.sb){n.push({type_:"entitySkip"})}if(!e.o&&!e.q&&!e.d&&!e.b&&!e.p&&r!==2){e.o=e.a;e.a=undefined}else if(!e.o&&!e.q&&!e.d&&(e.b||e.p)){e.o=e.a;e.d=e.b;e.q=e.p;e.a=e.b=e.p=undefined}else{if(e.o&&e.dType==="kv"&&mhchemParser.patterns.match_("d-oxidation$",e.d||"")){e.dType="oxidation"}else if(e.o&&e.dType==="kv"&&!e.q){e.dType=undefined}}n.push({type_:"chemfive",a:mhchemParser.go(e.a,"a"),b:mhchemParser.go(e.b,"bd"),p:mhchemParser.go(e.p,"pq"),o:mhchemParser.go(e.o,"o"),q:mhchemParser.go(e.q,"pq"),d:mhchemParser.go(e.d,e.dType==="oxidation"?"oxidation":"bd"),dType:e.dType})}}else{var o;if(e.rdt==="M"){o=mhchemParser.go(e.rd,"tex-math")}else if(e.rdt==="T"){o=[{type_:"text",p1:e.rd||""}]}else{o=mhchemParser.go(e.rd)}var a;if(e.rqt==="M"){a=mhchemParser.go(e.rq,"tex-math")}else if(e.rqt==="T"){a=[{type_:"text",p1:e.rq||""}]}else{a=mhchemParser.go(e.rq)}n={type_:"arrow",r:e.r,rd:o,rq:a}}for(var i in e){if(i!=="parenthesisLevel"&&i!=="beginsWithBond"){delete e[i]}}return n},"oxidation-output":function(e,t){var r=["{"];mhchemParser.concatArray(r,mhchemParser.go(t,"oxidation"));r.push("}");return r},"frac-output":function(e,t){return{type_:"frac-ce",p1:mhchemParser.go(t[0]),p2:mhchemParser.go(t[1])}},"overset-output":function(e,t){return{type_:"overset",p1:mhchemParser.go(t[0]),p2:mhchemParser.go(t[1])}},"underset-output":function(e,t){return{type_:"underset",p1:mhchemParser.go(t[0]),p2:mhchemParser.go(t[1])}},"underbrace-output":function(e,t){return{type_:"underbrace",p1:mhchemParser.go(t[0]),p2:mhchemParser.go(t[1])}},"color-output":function(e,t){return{type_:"color",color1:t[0],color2:mhchemParser.go(t[1])}},"r=":function(e,t){e.r=t},"rdt=":function(e,t){e.rdt=t},"rd=":function(e,t){e.rd=t},"rqt=":function(e,t){e.rqt=t},"rq=":function(e,t){e.rq=t},operator:function(e,t,r){return{type_:"operator",kind_:r||t}}}},a:{transitions:mhchemParser.createTransitions({empty:{"*":{}},"1/2$":{0:{action_:"1/2"}},else:{0:{nextState:"1",revisit:true}},"$(...)$":{"*":{action_:"tex-math tight",nextState:"1"}},",":{"*":{action_:{type_:"insert",option:"commaDecimal"}}},else2:{"*":{action_:"copy"}}}),actions:{}},o:{transitions:mhchemParser.createTransitions({empty:{"*":{}},"1/2$":{0:{action_:"1/2"}},else:{0:{nextState:"1",revisit:true}},letters:{"*":{action_:"rm"}},"\\ca":{"*":{action_:{type_:"insert",option:"circa"}}},"\\x{}{}|\\x{}|\\x":{"*":{action_:"copy"}},"${(...)}$|$(...)$":{"*":{action_:"tex-math"}},"{(...)}":{"*":{action_:"{text}"}},else2:{"*":{action_:"copy"}}}),actions:{}},text:{transitions:mhchemParser.createTransitions({empty:{"*":{action_:"output"}},"{...}":{"*":{action_:"text="}},"${(...)}$|$(...)$":{"*":{action_:"tex-math"}},"\\greek":{"*":{action_:["output","rm"]}},"\\,|\\x{}{}|\\x{}|\\x":{"*":{action_:["output","copy"]}},else:{"*":{action_:"text="}}}),actions:{output:function(e){if(e.text_){var t={type_:"text",p1:e.text_};for(var r in e){delete e[r]}return t}}}},pq:{transitions:mhchemParser.createTransitions({empty:{"*":{}},"state of aggregation $":{"*":{action_:"state of aggregation"}},i$:{0:{nextState:"!f",revisit:true}},"(KV letters),":{0:{action_:"rm",nextState:"0"}},formula$:{0:{nextState:"f",revisit:true}},"1/2$":{0:{action_:"1/2"}},else:{0:{nextState:"!f",revisit:true}},"${(...)}$|$(...)$":{"*":{action_:"tex-math"}},"{(...)}":{"*":{action_:"text"}},"a-z":{f:{action_:"tex-math"}},letters:{"*":{action_:"rm"}},"-9.,9":{"*":{action_:"9,9"}},",":{"*":{action_:{type_:"insert+p1",option:"comma enumeration S"}}},"\\color{(...)}{(...)}1|\\color(...){(...)}2":{"*":{action_:"color-output"}},"\\color{(...)}0":{"*":{action_:"color0-output"}},"\\ce{(...)}":{"*":{action_:"ce"}},"\\,|\\x{}{}|\\x{}|\\x":{"*":{action_:"copy"}},else2:{"*":{action_:"copy"}}}),actions:{"state of aggregation":function(e,t){return{type_:"state of aggregation subscript",p1:mhchemParser.go(t,"o")}},"color-output":function(e,t){return{type_:"color",color1:t[0],color2:mhchemParser.go(t[1],"pq")}}}},bd:{transitions:mhchemParser.createTransitions({empty:{"*":{}},x$:{0:{nextState:"!f",revisit:true}},formula$:{0:{nextState:"f",revisit:true}},else:{0:{nextState:"!f",revisit:true}},"-9.,9 no missing 0":{"*":{action_:"9,9"}},".":{"*":{action_:{type_:"insert",option:"electron dot"}}},"a-z":{f:{action_:"tex-math"}},x:{"*":{action_:{type_:"insert",option:"KV x"}}},letters:{"*":{action_:"rm"}},"'":{"*":{action_:{type_:"insert",option:"prime"}}},"${(...)}$|$(...)$":{"*":{action_:"tex-math"}},"{(...)}":{"*":{action_:"text"}},"\\color{(...)}{(...)}1|\\color(...){(...)}2":{"*":{action_:"color-output"}},"\\color{(...)}0":{"*":{action_:"color0-output"}},"\\ce{(...)}":{"*":{action_:"ce"}},"\\,|\\x{}{}|\\x{}|\\x":{"*":{action_:"copy"}},else2:{"*":{action_:"copy"}}}),actions:{"color-output":function(e,t){return{type_:"color",color1:t[0],color2:mhchemParser.go(t[1],"bd")}}}},oxidation:{transitions:mhchemParser.createTransitions({empty:{"*":{}},"roman numeral":{"*":{action_:"roman-numeral"}},"${(...)}$|$(...)$":{"*":{action_:"tex-math"}},else:{"*":{action_:"copy"}}}),actions:{"roman-numeral":function(e,t){return{type_:"roman numeral",p1:t||""}}}},"tex-math":{transitions:mhchemParser.createTransitions({empty:{"*":{action_:"output"}},"\\ce{(...)}":{"*":{action_:["output","ce"]}},"{...}|\\,|\\x{}{}|\\x{}|\\x":{"*":{action_:"o="}},else:{"*":{action_:"o="}}}),actions:{output:function(e){if(e.o){var t={type_:"tex-math",p1:e.o};for(var r in e){delete e[r]}return t}}}},"tex-math tight":{transitions:mhchemParser.createTransitions({empty:{"*":{action_:"output"}},"\\ce{(...)}":{"*":{action_:["output","ce"]}},"{...}|\\,|\\x{}{}|\\x{}|\\x":{"*":{action_:"o="}},"-|+":{"*":{action_:"tight operator"}},else:{"*":{action_:"o="}}}),actions:{"tight operator":function(e,t){e.o=(e.o||"")+"{"+t+"}"},output:function(e){if(e.o){var t={type_:"tex-math",p1:e.o};for(var r in e){delete e[r]}return t}}}},"9,9":{transitions:mhchemParser.createTransitions({empty:{"*":{}},",":{"*":{action_:"comma"}},else:{"*":{action_:"copy"}}}),actions:{comma:function(){return{type_:"commaDecimal"}}}},pu:{transitions:mhchemParser.createTransitions({empty:{"*":{action_:"output"}},space$:{"*":{action_:["output","space"]}},"{[(|)]}":{"0|a":{action_:"copy"}},"(-)(9)^(-9)":{0:{action_:"number^",nextState:"a"}},"(-)(9.,9)(e)(99)":{0:{action_:"enumber",nextState:"a"}},space:{"0|a":{}},"pm-operator":{"0|a":{action_:{type_:"operator",option:"\\pm"},nextState:"0"}},operator:{"0|a":{action_:"copy",nextState:"0"}},"//":{d:{action_:"o=",nextState:"/"}},"/":{d:{action_:"o=",nextState:"/"}},"{...}|else":{"0|d":{action_:"d=",nextState:"d"},a:{action_:["space","d="],nextState:"d"},"/|q":{action_:"q=",nextState:"q"}}}),actions:{enumber:function(e,t){var r=[];if(t[0]==="+-"||t[0]==="+/-"){r.push("\\pm ")}else if(t[0]){r.push(t[0])}if(t[1]){mhchemParser.concatArray(r,mhchemParser.go(t[1],"pu-9,9"));if(t[2]){if(t[2].match(/[,.]/)){mhchemParser.concatArray(r,mhchemParser.go(t[2],"pu-9,9"))}else{r.push(t[2])}}t[3]=t[4]||t[3];if(t[3]){t[3]=t[3].trim();if(t[3]==="e"||t[3].substr(0,1)==="*"){r.push({type_:"cdot"})}else{r.push({type_:"times"})}}}if(t[3]){r.push("10^{"+t[5]+"}")}return r},"number^":function(e,t){var r=[];if(t[0]==="+-"||t[0]==="+/-"){r.push("\\pm ")}else if(t[0]){r.push(t[0])}mhchemParser.concatArray(r,mhchemParser.go(t[1],"pu-9,9"));r.push("^{"+t[2]+"}");return r},operator:function(e,t,r){return{type_:"operator",kind_:r||t}},space:function(){return{type_:"pu-space-1"}},output:function(e){var t;var r=mhchemParser.patterns.match_("{(...)}",e.d||"");if(r&&r.remainder===""){e.d=r.match_}var n=mhchemParser.patterns.match_("{(...)}",e.q||"");if(n&&n.remainder===""){e.q=n.match_}if(e.d){e.d=e.d.replace(/\u00B0C|\^oC|\^{o}C/g,"{}^{\\circ}C");e.d=e.d.replace(/\u00B0F|\^oF|\^{o}F/g,"{}^{\\circ}F")}if(e.q){e.q=e.q.replace(/\u00B0C|\^oC|\^{o}C/g,"{}^{\\circ}C");e.q=e.q.replace(/\u00B0F|\^oF|\^{o}F/g,"{}^{\\circ}F");var o={d:mhchemParser.go(e.d,"pu"),q:mhchemParser.go(e.q,"pu")};if(e.o==="//"){t={type_:"pu-frac",p1:o.d,p2:o.q}}else{t=o.d;if(o.d.length>1||o.q.length>1){t.push({type_:" / "})}else{t.push({type_:"/"})}mhchemParser.concatArray(t,o.q)}}else{t=mhchemParser.go(e.d,"pu-2")}for(var a in e){delete e[a]}return t}}},"pu-2":{transitions:mhchemParser.createTransitions({empty:{"*":{action_:"output"}},"*":{"*":{action_:["output","cdot"],nextState:"0"}},"\\x":{"*":{action_:"rm="}},space:{"*":{action_:["output","space"],nextState:"0"}},"^{(...)}|^(-1)":{1:{action_:"^(-1)"}},"-9.,9":{0:{action_:"rm=",nextState:"0"},1:{action_:"^(-1)",nextState:"0"}},"{...}|else":{"*":{action_:"rm=",nextState:"1"}}}),actions:{cdot:function(){return{type_:"tight cdot"}},"^(-1)":function(e,t){e.rm+="^{"+t+"}"},space:function(){return{type_:"pu-space-2"}},output:function(e){var t=[];if(e.rm){var r=mhchemParser.patterns.match_("{(...)}",e.rm||"");if(r&&r.remainder===""){t=mhchemParser.go(r.match_,"pu")}else{t={type_:"rm",p1:e.rm}}}for(var n in e){delete e[n]}return t}}},"pu-9,9":{transitions:mhchemParser.createTransitions({empty:{0:{action_:"output-0"},o:{action_:"output-o"}},",":{0:{action_:["output-0","comma"],nextState:"o"}},".":{0:{action_:["output-0","copy"],nextState:"o"}},else:{"*":{action_:"text="}}}),actions:{comma:function(){return{type_:"commaDecimal"}},"output-0":function(e){var t=[];e.text_=e.text_||"";if(e.text_.length>4){var r=e.text_.length%3;if(r===0){r=3}for(var n=e.text_.length-3;n>0;n-=3){t.push(e.text_.substr(n,3));t.push({type_:"1000 separator"})}t.push(e.text_.substr(0,r));t.reverse()}else{t.push(e.text_)}for(var o in e){delete e[o]}return t},"output-o":function(e){var t=[];e.text_=e.text_||"";if(e.text_.length>4){var r=e.text_.length-3;for(var n=0;n<r;n+=3){t.push(e.text_.substr(n,3));t.push({type_:"1000 separator"})}t.push(e.text_.substr(n))}else{t.push(e.text_)}for(var o in e){delete e[o]}return t}}}};var texify={go:function(e,t){if(!e){return""}var r="";var n=false;for(var o=0;o<e.length;o++){var a=e[o];if(typeof a==="string"){r+=a}else{r+=texify._go2(a);if(a.type_==="1st-level escape"){n=true}}}if(!t&&!n&&r){r="{"+r+"}"}return r},_goInner:function(e){if(!e){return e}return texify.go(e,true)},_go2:function(e){var t;switch(e.type_){case"chemfive":t="";var r={a:texify._goInner(e.a),b:texify._goInner(e.b),p:texify._goInner(e.p),o:texify._goInner(e.o),q:texify._goInner(e.q),d:texify._goInner(e.d)};if(r.a){if(r.a.match(/^[+\-]/)){r.a="{"+r.a+"}"}t+=r.a+"\\,"}if(r.b||r.p){t+="{\\vphantom{X}}";t+="^{\\hphantom{"+(r.b||"")+"}}_{\\hphantom{"+(r.p||"")+"}}";t+="{\\vphantom{X}}";t+="^{\\smash[t]{\\vphantom{2}}\\mathllap{"+(r.b||"")+"}}";t+="_{\\vphantom{2}\\mathllap{\\smash[t]{"+(r.p||"")+"}}}"}if(r.o){if(r.o.match(/^[+\-]/)){r.o="{"+r.o+"}"}t+=r.o}if(e.dType==="kv"){if(r.d||r.q){t+="{\\vphantom{X}}"}if(r.d){t+="^{"+r.d+"}"}if(r.q){t+="_{\\smash[t]{"+r.q+"}}"}}else if(e.dType==="oxidation"){if(r.d){t+="{\\vphantom{X}}";t+="^{"+r.d+"}"}if(r.q){t+="{{}}";t+="_{\\smash[t]{"+r.q+"}}"}}else{if(r.q){t+="{{}}";t+="_{\\smash[t]{"+r.q+"}}"}if(r.d){t+="{{}}";t+="^{"+r.d+"}"}}break;case"rm":t="\\mathrm{"+e.p1+"}";break;case"text":if(e.p1.match(/[\^_]/)){e.p1=e.p1.replace(" ","~").replace("-","\\text{-}");t="\\mathrm{"+e.p1+"}"}else{t="\\text{"+e.p1+"}"}break;case"roman numeral":t="\\mathrm{"+e.p1+"}";break;case"state of aggregation":t="\\mskip2mu "+texify._goInner(e.p1);break;case"state of aggregation subscript":t="\\mskip1mu "+texify._goInner(e.p1);break;case"bond":t=texify._getBond(e.kind_);if(!t){throw["MhchemErrorBond","mhchem Error. Unknown bond type ("+e.kind_+")"]}break;case"frac":var n="\\frac{"+e.p1+"}{"+e.p2+"}";t="\\mathchoice{\\textstyle"+n+"}{"+n+"}{"+n+"}{"+n+"}";break;case"pu-frac":var o="\\frac{"+texify._goInner(e.p1)+"}{"+texify._goInner(e.p2)+"}";t="\\mathchoice{\\textstyle"+o+"}{"+o+"}{"+o+"}{"+o+"}";break;case"tex-math":t=e.p1+" ";break;case"frac-ce":t="\\frac{"+texify._goInner(e.p1)+"}{"+texify._goInner(e.p2)+"}";break;case"overset":t="\\overset{"+texify._goInner(e.p1)+"}{"+texify._goInner(e.p2)+"}";break;case"underset":t="\\underset{"+texify._goInner(e.p1)+"}{"+texify._goInner(e.p2)+"}";break;case"underbrace":t="\\underbrace{"+texify._goInner(e.p1)+"}_{"+texify._goInner(e.p2)+"}";break;case"color":t="{\\color{"+e.color1+"}{"+texify._goInner(e.color2)+"}}";break;case"color0":t="\\color{"+e.color+"}";break;case"arrow":var a={rd:texify._goInner(e.rd),rq:texify._goInner(e.rq)};var i=texify._getArrow(e.r);if(a.rq){i+="[{\\rm "+a.rq+"}]"}if(a.rd){i+="{\\rm "+a.rd+"}"}else{i+="{}"}t=i;break;case"operator":t=texify._getOperator(e.kind_);break;case"1st-level escape":t=e.p1+" ";break;case"space":t=" ";break;case"entitySkip":t="~";break;case"pu-space-1":t="~";break;case"pu-space-2":t="\\mkern3mu ";break;case"1000 separator":t="\\mkern2mu ";break;case"commaDecimal":t="{,}";break;case"comma enumeration L":t="{"+e.p1+"}\\mkern6mu ";break;case"comma enumeration M":t="{"+e.p1+"}\\mkern3mu ";break;case"comma enumeration S":t="{"+e.p1+"}\\mkern1mu ";break;case"hyphen":t="\\text{-}";break;case"addition compound":t="\\,{\\cdot}\\,";break;case"electron dot":t="\\mkern1mu \\text{\\textbullet}\\mkern1mu ";break;case"KV x":t="{\\times}";break;case"prime":t="\\prime ";break;case"cdot":t="\\cdot ";break;case"tight cdot":t="\\mkern1mu{\\cdot}\\mkern1mu ";break;case"times":t="\\times ";break;case"circa":t="{\\sim}";break;case"^":t="uparrow";break;case"v":t="downarrow";break;case"ellipsis":t="\\ldots ";break;case"/":t="/";break;case" / ":t="\\,/\\,";break;default:assertNever(e);throw["MhchemBugT","mhchem bug T. Please report."]}assertString(t);return t},_getArrow:function(e){switch(e){case"->":return"\\yields";case"→":return"\\yields";case"⟶":return"\\yields";case"<-":return"\\yieldsLeft";case"<->":return"\\mesomerism";case"<--\x3e":return"\\yieldsLeftRight";case"<=>":return"\\equilibrium";case"⇌":return"\\equilibrium";case"<=>>":return"\\equilibriumRight";case"<<=>":return"\\equilibriumLeft";default:assertNever(e);throw["MhchemBugT","mhchem bug T. Please report."]}},_getBond:function(e){switch(e){case"-":return"{-}";case"1":return"{-}";case"=":return"{=}";case"2":return"{=}";case"#":return"{\\equiv}";case"3":return"{\\equiv}";case"~":return"{\\tripleDash}";case"~-":return"{\\tripleDashOverLine}";case"~=":return"{\\tripleDashOverDoubleLine}";case"~--":return"{\\tripleDashOverDoubleLine}";case"-~-":return"{\\tripleDashBetweenDoubleLine}";case"...":return"{{\\cdot}{\\cdot}{\\cdot}}";case"....":return"{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";case"->":return"{\\rightarrow}";case"<-":return"{\\leftarrow}";case"<":return"{<}";case">":return"{>}";default:assertNever(e);throw["MhchemBugT","mhchem bug T. Please report."]}},_getOperator:function(e){switch(e){case"+":return" {}+{} ";case"-":return" {}-{} ";case"=":return" {}={} ";case"<":return" {}<{} ";case">":return" {}>{} ";case"<<":return" {}\\ll{} ";case">>":return" {}\\gg{} ";case"\\pm":return" {}\\pm{} ";case"\\approx":return" {}\\approx{} ";case"$\\approx$":return" {}\\approx{} ";case"v":return" \\downarrow{} ";case"(v)":return" \\downarrow{} ";case"^":return" \\uparrow{} ";case"(^)":return" \\uparrow{} ";default:assertNever(e);throw["MhchemBugT","mhchem bug T. Please report."]}}};function assertNever(e){}function assertString(e){}defineMacro("\\darr","\\downarrow");defineMacro("\\dArr","\\Downarrow");defineMacro("\\Darr","\\Downarrow");defineMacro("\\lang","\\langle");defineMacro("\\rang","\\rangle");defineMacro("\\uarr","\\uparrow");defineMacro("\\uArr","\\Uparrow");defineMacro("\\Uarr","\\Uparrow");defineMacro("\\N","\\mathbb{N}");defineMacro("\\R","\\mathbb{R}");defineMacro("\\Z","\\mathbb{Z}");defineMacro("\\alef","\\aleph");defineMacro("\\alefsym","\\aleph");defineMacro("\\bull","\\bullet");defineMacro("\\clubs","\\clubsuit");defineMacro("\\cnums","\\mathbb{C}");defineMacro("\\Complex","\\mathbb{C}");defineMacro("\\Dagger","\\ddagger");defineMacro("\\diamonds","\\diamondsuit");defineMacro("\\empty","\\emptyset");defineMacro("\\exist","\\exists");defineMacro("\\harr","\\leftrightarrow");defineMacro("\\hArr","\\Leftrightarrow");defineMacro("\\Harr","\\Leftrightarrow");defineMacro("\\hearts","\\heartsuit");defineMacro("\\image","\\Im");defineMacro("\\infin","\\infty");defineMacro("\\isin","\\in");defineMacro("\\larr","\\leftarrow");defineMacro("\\lArr","\\Leftarrow");defineMacro("\\Larr","\\Leftarrow");defineMacro("\\lrarr","\\leftrightarrow");defineMacro("\\lrArr","\\Leftrightarrow");defineMacro("\\Lrarr","\\Leftrightarrow");defineMacro("\\natnums","\\mathbb{N}");defineMacro("\\plusmn","\\pm");defineMacro("\\rarr","\\rightarrow");defineMacro("\\rArr","\\Rightarrow");defineMacro("\\Rarr","\\Rightarrow");defineMacro("\\real","\\Re");defineMacro("\\reals","\\mathbb{R}");defineMacro("\\Reals","\\mathbb{R}");defineMacro("\\sdot","\\cdot");defineMacro("\\sect","\\S");defineMacro("\\spades","\\spadesuit");defineMacro("\\sub","\\subset");defineMacro("\\sube","\\subseteq");defineMacro("\\supe","\\supseteq");defineMacro("\\thetasym","\\vartheta");defineMacro("\\weierp","\\wp");defineMacro("\\quantity","{\\left\\{ #1 \\right\\}}");defineMacro("\\qty","{\\left\\{ #1 \\right\\}}");defineMacro("\\pqty","{\\left( #1 \\right)}");defineMacro("\\bqty","{\\left[ #1 \\right]}");defineMacro("\\vqty","{\\left\\vert #1 \\right\\vert}");defineMacro("\\Bqty","{\\left\\{ #1 \\right\\}}");defineMacro("\\absolutevalue","{\\left\\vert #1 \\right\\vert}");defineMacro("\\abs","{\\left\\vert #1 \\right\\vert}");defineMacro("\\norm","{\\left\\Vert #1 \\right\\Vert}");defineMacro("\\evaluated","{\\left.#1 \\right\\vert}");defineMacro("\\eval","{\\left.#1 \\right\\vert}");defineMacro("\\order","{\\mathcal{O} \\left( #1 \\right)}");defineMacro("\\commutator","{\\left[ #1 , #2 \\right]}");defineMacro("\\comm","{\\left[ #1 , #2 \\right]}");defineMacro("\\anticommutator","{\\left\\{ #1 , #2 \\right\\}}");defineMacro("\\acomm","{\\left\\{ #1 , #2 \\right\\}}");defineMacro("\\poissonbracket","{\\left\\{ #1 , #2 \\right\\}}");defineMacro("\\pb","{\\left\\{ #1 , #2 \\right\\}}");defineMacro("\\vectorbold","{\\boldsymbol{ #1 }}");defineMacro("\\vb","{\\boldsymbol{ #1 }}");defineMacro("\\vectorarrow","{\\vec{\\boldsymbol{ #1 }}}");defineMacro("\\va","{\\vec{\\boldsymbol{ #1 }}}");defineMacro("\\vectorunit","{{\\boldsymbol{\\hat{ #1 }}}}");defineMacro("\\vu","{{\\boldsymbol{\\hat{ #1 }}}}");defineMacro("\\dotproduct","\\mathbin{\\boldsymbol\\cdot}");defineMacro("\\vdot","{\\boldsymbol\\cdot}");defineMacro("\\crossproduct","\\mathbin{\\boldsymbol\\times}");defineMacro("\\cross","\\mathbin{\\boldsymbol\\times}");defineMacro("\\cp","\\mathbin{\\boldsymbol\\times}");defineMacro("\\gradient","{\\boldsymbol\\nabla}");defineMacro("\\grad","{\\boldsymbol\\nabla}");defineMacro("\\divergence","{\\grad\\vdot}");defineMacro("\\curl","{\\grad\\cross}");defineMacro("\\laplacian","\\nabla^2");defineMacro("\\tr","{\\operatorname{tr}}");defineMacro("\\Tr","{\\operatorname{Tr}}");defineMacro("\\rank","{\\operatorname{rank}}");defineMacro("\\erf","{\\operatorname{erf}}");defineMacro("\\Res","{\\operatorname{Res}}");defineMacro("\\principalvalue","{\\mathcal{P}}");defineMacro("\\pv","{\\mathcal{P}}");defineMacro("\\PV","{\\operatorname{P.V.}}");defineMacro("\\qqtext","{\\quad\\text{ #1 }\\quad}");defineMacro("\\qq","{\\quad\\text{ #1 }\\quad}");defineMacro("\\qcomma","{\\text{,}\\quad}");defineMacro("\\qc","{\\text{,}\\quad}");defineMacro("\\qcc","{\\quad\\text{c.c.}\\quad}");defineMacro("\\qif","{\\quad\\text{if}\\quad}");defineMacro("\\qthen","{\\quad\\text{then}\\quad}");defineMacro("\\qelse","{\\quad\\text{else}\\quad}");defineMacro("\\qotherwise","{\\quad\\text{otherwise}\\quad}");defineMacro("\\qunless","{\\quad\\text{unless}\\quad}");defineMacro("\\qgiven","{\\quad\\text{given}\\quad}");defineMacro("\\qusing","{\\quad\\text{using}\\quad}");defineMacro("\\qassume","{\\quad\\text{assume}\\quad}");defineMacro("\\qsince","{\\quad\\text{since}\\quad}");defineMacro("\\qlet","{\\quad\\text{let}\\quad}");defineMacro("\\qfor","{\\quad\\text{for}\\quad}");defineMacro("\\qall","{\\quad\\text{all}\\quad}");defineMacro("\\qeven","{\\quad\\text{even}\\quad}");defineMacro("\\qodd","{\\quad\\text{odd}\\quad}");defineMacro("\\qinteger","{\\quad\\text{integer}\\quad}");defineMacro("\\qand","{\\quad\\text{and}\\quad}");defineMacro("\\qor","{\\quad\\text{or}\\quad}");defineMacro("\\qas","{\\quad\\text{as}\\quad}");defineMacro("\\qin","{\\quad\\text{in}\\quad}");defineMacro("\\differential","{\\text{d}}");defineMacro("\\dd","{\\text{d}}");defineMacro("\\derivative","{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");defineMacro("\\dv","{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");defineMacro("\\partialderivative","{\\frac{\\partial{ #1 }}{\\partial{ #2 }}}");defineMacro("\\variation","{\\delta}");defineMacro("\\var","{\\delta}");defineMacro("\\functionalderivative","{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");defineMacro("\\fdv","{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");defineMacro("\\innerproduct","{\\left\\langle {#1} \\mid { #2} \\right\\rangle}");defineMacro("\\outerproduct","{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");defineMacro("\\dyad","{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");defineMacro("\\ketbra","{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");defineMacro("\\op","{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");defineMacro("\\expectationvalue","{\\left\\langle {#1 } \\right\\rangle}");defineMacro("\\expval","{\\left\\langle {#1 } \\right\\rangle}");defineMacro("\\ev","{\\left\\langle {#1 } \\right\\rangle}");defineMacro("\\matrixelement","{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");defineMacro("\\matrixel","{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");defineMacro("\\mel","{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");const implicitCommands={"^":true,_:true,"\\limits":true,"\\nolimits":true};class MacroExpander{constructor(e,t,r){this.settings=t;this.expansionCount=0;this.feed(e);this.macros=new Namespace(macros,t.macros);this.mode=r;this.stack=[]}feed(e){this.lexer=new Lexer(e,this.settings)}switchMode(e){this.mode=e}beginGroup(){this.macros.beginGroup()}endGroup(){this.macros.endGroup()}future(){if(this.stack.length===0){this.pushToken(this.lexer.lex())}return this.stack[this.stack.length-1]}popToken(){this.future();return this.stack.pop()}pushToken(e){this.stack.push(e)}pushTokens(e){this.stack.push(...e)}scanArgument(e){let t;let r;let n;if(e){this.consumeSpaces();if(this.future().text!=="["){return null}t=this.popToken();({tokens:n,end:r}=this.consumeArg(["]"]))}else{({tokens:n,start:t,end:r}=this.consumeArg())}this.pushToken(new Token("EOF",r.loc));this.pushTokens(n);return t.range(r,"")}consumeSpaces(){for(;;){const e=this.future();if(e.text===" "){this.stack.pop()}else{break}}}consumeArg(e){const t=[];const r=e&&e.length>0;if(!r){this.consumeSpaces()}const n=this.future();let o;let a=0;let i=0;do{o=this.popToken();t.push(o);if(o.text==="{"){++a}else if(o.text==="}"){--a;if(a===-1){throw new ParseError("Extra }",o)}}else if(o.text==="EOF"){throw new ParseError("Unexpected end of input in a macro argument"+", expected '"+(e&&r?e[i]:"}")+"'",o)}if(e&&r){if((a===0||a===1&&e[i]==="{")&&o.text===e[i]){++i;if(i===e.length){t.splice(-i,i);break}}else{i=0}}}while(a!==0||r);if(n.text==="{"&&t[t.length-1].text==="}"){t.pop();t.shift()}t.reverse();return{tokens:t,start:n,end:o}}consumeArgs(e,t){if(t){if(t.length!==e+1){throw new ParseError("The length of delimiters doesn't match the number of args!")}const r=t[0];for(let e=0;e<r.length;e++){const t=this.popToken();if(r[e]!==t.text){throw new ParseError("Use of the macro doesn't match its definition",t)}}}const r=[];for(let n=0;n<e;n++){r.push(this.consumeArg(t&&t[n+1]).tokens)}return r}expandOnce(e){const t=this.popToken();const r=t.text;const n=!t.noexpand?this._getExpansion(r):null;if(n==null||e&&n.unexpandable){if(e&&n==null&&r[0]==="\\"&&!this.isDefined(r)){throw new ParseError("Undefined control sequence: "+r)}this.pushToken(t);return t}this.expansionCount++;if(this.expansionCount>this.settings.maxExpand){throw new ParseError("Too many expansions: infinite loop or "+"need to increase maxExpand setting")}let o=n.tokens;const a=this.consumeArgs(n.numArgs,n.delimiters);if(n.numArgs){o=o.slice();for(let e=o.length-1;e>=0;--e){let t=o[e];if(t.text==="#"){if(e===0){throw new ParseError("Incomplete placeholder at end of macro body",t)}t=o[--e];if(t.text==="#"){o.splice(e+1,1)}else if(/^[1-9]$/.test(t.text)){o.splice(e,2,...a[+t.text-1])}else{throw new ParseError("Not a valid argument number",t)}}}}this.pushTokens(o);return o}expandAfterFuture(){this.expandOnce();return this.future()}expandNextToken(){for(;;){const e=this.expandOnce();if(e instanceof Token){if(e.treatAsRelax){e.text="\\relax"}return this.stack.pop()}}throw new Error}expandMacro(e){return this.macros.has(e)?this.expandTokens([new Token(e)]):undefined}expandTokens(e){const t=[];const r=this.stack.length;this.pushTokens(e);while(this.stack.length>r){const e=this.expandOnce(true);if(e instanceof Token){if(e.treatAsRelax){e.noexpand=false;e.treatAsRelax=false}t.push(this.stack.pop())}}return t}expandMacroAsText(e){const t=this.expandMacro(e);if(t){return t.map((e=>e.text)).join("")}else{return t}}_getExpansion(e){const t=this.macros.get(e);if(t==null){return t}if(e.length===1){const t=this.lexer.catcodes[e];if(t!=null&&t!==13){return}}const r=typeof t==="function"?t(this):t;if(typeof r==="string"){let e=0;if(r.indexOf("#")!==-1){const t=r.replace(/##/g,"");while(t.indexOf("#"+(e+1))!==-1){++e}}const t=new Lexer(r,this.settings);const n=[];let o=t.lex();while(o.text!=="EOF"){n.push(o);o=t.lex()}n.reverse();const a={tokens:n,numArgs:e};return a}return r}isDefined(e){return this.macros.has(e)||Object.prototype.hasOwnProperty.call(functions,e)||Object.prototype.hasOwnProperty.call(symbols.math,e)||Object.prototype.hasOwnProperty.call(symbols.text,e)||Object.prototype.hasOwnProperty.call(implicitCommands,e)}isExpandable(e){const t=this.macros.get(e);return t!=null?typeof t==="string"||typeof t==="function"||!t.unexpandable:Object.prototype.hasOwnProperty.call(functions,e)&&!functions[e].primitive}}const scriptData=[{name:"latin",blocks:[[256,591],[768,879]]},{name:"cyrillic",blocks:[[1024,1279]]},{name:"armenian",blocks:[[1328,1423]]},{name:"brahmic",blocks:[[2304,4255]]},{name:"georgian",blocks:[[4256,4351]]},{name:"cjk",blocks:[[12288,12543],[19968,40879],[65280,65376]]},{name:"hangul",blocks:[[44032,55215]]}];const allBlocks=[];scriptData.forEach((e=>e.blocks.forEach((e=>allBlocks.push(...e)))));function supportedCodepoint(e){for(let t=0;t<allBlocks.length;t+=2){if(e>=allBlocks[t]&&e<=allBlocks[t+1]){return true}}return false}const unicodeSubRegEx=/^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;const uSubsAndSups=Object.freeze({"₊":"+","₋":"-","₌":"=","₍":"(","₎":")","₀":"0","₁":"1","₂":"2","₃":"3","₄":"4","₅":"5","₆":"6","₇":"7","₈":"8","₉":"9","ₐ":"a","ₑ":"e","ₕ":"h","ᵢ":"i","ⱼ":"j","ₖ":"k","ₗ":"l","ₘ":"m","ₙ":"n","ₒ":"o","ₚ":"p","ᵣ":"r","ₛ":"s","ₜ":"t","ᵤ":"u","ᵥ":"v","ₓ":"x","ᵦ":"β","ᵧ":"γ","ᵨ":"ρ","ᵩ":"ϕ","ᵪ":"χ","⁺":"+","⁻":"-","⁼":"=","⁽":"(","⁾":")","⁰":"0","¹":"1","²":"2","³":"3","⁴":"4","⁵":"5","⁶":"6","⁷":"7","⁸":"8","⁹":"9","ᴬ":"A","ᴮ":"B","ᴰ":"D","ᴱ":"E","ᴳ":"G","ᴴ":"H","ᴵ":"I","ᴶ":"J","ᴷ":"K","ᴸ":"L","ᴹ":"M","ᴺ":"N","ᴼ":"O","ᴾ":"P","ᴿ":"R","ᵀ":"T","ᵁ":"U","ⱽ":"V","ᵂ":"W","ᵃ":"a","ᵇ":"b","ᶜ":"c","ᵈ":"d","ᵉ":"e","ᶠ":"f","ᵍ":"g","ʰ":"h","ⁱ":"i","ʲ":"j","ᵏ":"k","ˡ":"l","ᵐ":"m","ⁿ":"n","ᵒ":"o","ᵖ":"p","ʳ":"r","ˢ":"s","ᵗ":"t","ᵘ":"u","ᵛ":"v","ʷ":"w","ˣ":"x","ʸ":"y","ᶻ":"z","ᵝ":"β","ᵞ":"γ","ᵟ":"δ","ᵠ":"ϕ","ᵡ":"χ","ᶿ":"θ"});const asciiFromScript=Object.freeze({"𝒜":"A","ℬ":"B","𝒞":"C","𝒟":"D","ℰ":"E","ℱ":"F","𝒢":"G","ℋ":"H","ℐ":"I","𝒥":"J","𝒦":"K","ℒ":"L","ℓ":"M","𝒩":"N","𝒪":"O","𝒫":"P","𝒬":"Q","ℛ":"R","𝒮":"S","𝒯":"T","𝒰":"U","𝒱":"V","𝒲":"W","𝒳":"X","𝒴":"Y","𝒵":"Z"});var unicodeAccents={"́":{text:"\\'",math:"\\acute"},"̀":{text:"\\`",math:"\\grave"},"̈":{text:'\\"',math:"\\ddot"},"̃":{text:"\\~",math:"\\tilde"},"̄":{text:"\\=",math:"\\bar"},"̆":{text:"\\u",math:"\\breve"},"̌":{text:"\\v",math:"\\check"},"̂":{text:"\\^",math:"\\hat"},"̇":{text:"\\.",math:"\\dot"},"̊":{text:"\\r",math:"\\mathring"},"̋":{text:"\\H"},"̧":{text:"\\c"}};var unicodeSymbols={"á":"á","à":"à","ä":"ä","ǟ":"ǟ","ã":"ã","ā":"ā","ă":"ă","ắ":"ắ","ằ":"ằ","ẵ":"ẵ","ǎ":"ǎ","â":"â","ấ":"ấ","ầ":"ầ","ẫ":"ẫ","ȧ":"ȧ","ǡ":"ǡ","å":"å","ǻ":"ǻ","ḃ":"ḃ","ć":"ć","č":"č","ĉ":"ĉ","ċ":"ċ","ď":"ď","ḋ":"ḋ","é":"é","è":"è","ë":"ë","ẽ":"ẽ","ē":"ē","ḗ":"ḗ","ḕ":"ḕ","ĕ":"ĕ","ě":"ě","ê":"ê","ế":"ế","ề":"ề","ễ":"ễ","ė":"ė","ḟ":"ḟ","ǵ":"ǵ","ḡ":"ḡ","ğ":"ğ","ǧ":"ǧ","ĝ":"ĝ","ġ":"ġ","ḧ":"ḧ","ȟ":"ȟ","ĥ":"ĥ","ḣ":"ḣ","í":"í","ì":"ì","ï":"ï","ḯ":"ḯ","ĩ":"ĩ","ī":"ī","ĭ":"ĭ","ǐ":"ǐ","î":"î","ǰ":"ǰ","ĵ":"ĵ","ḱ":"ḱ","ǩ":"ǩ","ĺ":"ĺ","ľ":"ľ","ḿ":"ḿ","ṁ":"ṁ","ń":"ń","ǹ":"ǹ","ñ":"ñ","ň":"ň","ṅ":"ṅ","ó":"ó","ò":"ò","ö":"ö","ȫ":"ȫ","õ":"õ","ṍ":"ṍ","ṏ":"ṏ","ȭ":"ȭ","ō":"ō","ṓ":"ṓ","ṑ":"ṑ","ŏ":"ŏ","ǒ":"ǒ","ô":"ô","ố":"ố","ồ":"ồ","ỗ":"ỗ","ȯ":"ȯ","ȱ":"ȱ","ő":"ő","ṕ":"ṕ","ṗ":"ṗ","ŕ":"ŕ","ř":"ř","ṙ":"ṙ","ś":"ś","ṥ":"ṥ","š":"š","ṧ":"ṧ","ŝ":"ŝ","ṡ":"ṡ","ẗ":"ẗ","ť":"ť","ṫ":"ṫ","ú":"ú","ù":"ù","ü":"ü","ǘ":"ǘ","ǜ":"ǜ","ǖ":"ǖ","ǚ":"ǚ","ũ":"ũ","ṹ":"ṹ","ū":"ū","ṻ":"ṻ","ŭ":"ŭ","ǔ":"ǔ","û":"û","ů":"ů","ű":"ű","ṽ":"ṽ","ẃ":"ẃ","ẁ":"ẁ","ẅ":"ẅ","ŵ":"ŵ","ẇ":"ẇ","ẘ":"ẘ","ẍ":"ẍ","ẋ":"ẋ","ý":"ý","ỳ":"ỳ","ÿ":"ÿ","ỹ":"ỹ","ȳ":"ȳ","ŷ":"ŷ","ẏ":"ẏ","ẙ":"ẙ","ź":"ź","ž":"ž","ẑ":"ẑ","ż":"ż","Á":"Á","À":"À","Ä":"Ä","Ǟ":"Ǟ","Ã":"Ã","Ā":"Ā","Ă":"Ă","Ắ":"Ắ","Ằ":"Ằ","Ẵ":"Ẵ","Ǎ":"Ǎ","Â":"Â","Ấ":"Ấ","Ầ":"Ầ","Ẫ":"Ẫ","Ȧ":"Ȧ","Ǡ":"Ǡ","Å":"Å","Ǻ":"Ǻ","Ḃ":"Ḃ","Ć":"Ć","Č":"Č","Ĉ":"Ĉ","Ċ":"Ċ","Ď":"Ď","Ḋ":"Ḋ","É":"É","È":"È","Ë":"Ë","Ẽ":"Ẽ","Ē":"Ē","Ḗ":"Ḗ","Ḕ":"Ḕ","Ĕ":"Ĕ","Ě":"Ě","Ê":"Ê","Ế":"Ế","Ề":"Ề","Ễ":"Ễ","Ė":"Ė","Ḟ":"Ḟ","Ǵ":"Ǵ","Ḡ":"Ḡ","Ğ":"Ğ","Ǧ":"Ǧ","Ĝ":"Ĝ","Ġ":"Ġ","Ḧ":"Ḧ","Ȟ":"Ȟ","Ĥ":"Ĥ","Ḣ":"Ḣ","Í":"Í","Ì":"Ì","Ï":"Ï","Ḯ":"Ḯ","Ĩ":"Ĩ","Ī":"Ī","Ĭ":"Ĭ","Ǐ":"Ǐ","Î":"Î","İ":"İ","Ĵ":"Ĵ","Ḱ":"Ḱ","Ǩ":"Ǩ","Ĺ":"Ĺ","Ľ":"Ľ","Ḿ":"Ḿ","Ṁ":"Ṁ","Ń":"Ń","Ǹ":"Ǹ","Ñ":"Ñ","Ň":"Ň","Ṅ":"Ṅ","Ó":"Ó","Ò":"Ò","Ö":"Ö","Ȫ":"Ȫ","Õ":"Õ","Ṍ":"Ṍ","Ṏ":"Ṏ","Ȭ":"Ȭ","Ō":"Ō","Ṓ":"Ṓ","Ṑ":"Ṑ","Ŏ":"Ŏ","Ǒ":"Ǒ","Ô":"Ô","Ố":"Ố","Ồ":"Ồ","Ỗ":"Ỗ","Ȯ":"Ȯ","Ȱ":"Ȱ","Ő":"Ő","Ṕ":"Ṕ","Ṗ":"Ṗ","Ŕ":"Ŕ","Ř":"Ř","Ṙ":"Ṙ","Ś":"Ś","Ṥ":"Ṥ","Š":"Š","Ṧ":"Ṧ","Ŝ":"Ŝ","Ṡ":"Ṡ","Ť":"Ť","Ṫ":"Ṫ","Ú":"Ú","Ù":"Ù","Ü":"Ü","Ǘ":"Ǘ","Ǜ":"Ǜ","Ǖ":"Ǖ","Ǚ":"Ǚ","Ũ":"Ũ","Ṹ":"Ṹ","Ū":"Ū","Ṻ":"Ṻ","Ŭ":"Ŭ","Ǔ":"Ǔ","Û":"Û","Ů":"Ů","Ű":"Ű","Ṽ":"Ṽ","Ẃ":"Ẃ","Ẁ":"Ẁ","Ẅ":"Ẅ","Ŵ":"Ŵ","Ẇ":"Ẇ","Ẍ":"Ẍ","Ẋ":"Ẋ","Ý":"Ý","Ỳ":"Ỳ","Ÿ":"Ÿ","Ỹ":"Ỹ","Ȳ":"Ȳ","Ŷ":"Ŷ","Ẏ":"Ẏ","Ź":"Ź","Ž":"Ž","Ẑ":"Ẑ","Ż":"Ż","ά":"ά","ὰ":"ὰ","ᾱ":"ᾱ","ᾰ":"ᾰ","έ":"έ","ὲ":"ὲ","ή":"ή","ὴ":"ὴ","ί":"ί","ὶ":"ὶ","ϊ":"ϊ","ΐ":"ΐ","ῒ":"ῒ","ῑ":"ῑ","ῐ":"ῐ","ό":"ό","ὸ":"ὸ","ύ":"ύ","ὺ":"ὺ","ϋ":"ϋ","ΰ":"ΰ","ῢ":"ῢ","ῡ":"ῡ","ῠ":"ῠ","ώ":"ώ","ὼ":"ὼ","Ύ":"Ύ","Ὺ":"Ὺ","Ϋ":"Ϋ","Ῡ":"Ῡ","Ῠ":"Ῠ","Ώ":"Ώ","Ὼ":"Ὼ"};const numberRegEx=/^\d(?:[\d,.]*\d)?$/;class Parser{constructor(e,t,r=false){this.mode="math";this.gullet=new MacroExpander(e,t,this.mode);this.settings=t;this.isPreamble=r;this.leftrightDepth=0;this.prevAtomType=""}expect(e,t=true){if(this.fetch().text!==e){throw new ParseError(`Expected '${e}', got '${this.fetch().text}'`,this.fetch())}if(t){this.consume()}}consume(){this.nextToken=null}fetch(){if(this.nextToken==null){this.nextToken=this.gullet.expandNextToken()}return this.nextToken}switchMode(e){this.mode=e;this.gullet.switchMode(e)}parse(){this.gullet.beginGroup();if(this.settings.colorIsTextColor){this.gullet.macros.set("\\color","\\textcolor")}const e=this.parseExpression(false);this.expect("EOF");if(this.isPreamble){const e=Object.create(null);Object.entries(this.gullet.macros.current).forEach((([t,r])=>{e[t]=r}));this.gullet.endGroup();return e}const t=this.gullet.macros.get("\\df@tag");this.gullet.endGroup();if(t){this.gullet.macros.current["\\df@tag"]=t}return e}static get endOfExpression(){return["}","\\endgroup","\\end","\\right","\\endtoggle","&"]}subparse(e){const t=this.nextToken;this.consume();this.gullet.pushToken(new Token("}"));this.gullet.pushTokens(e);const r=this.parseExpression(false);this.expect("}");this.nextToken=t;return r}parseExpression(e,t){const r=[];while(true){if(this.mode==="math"){this.consumeSpaces()}const n=this.fetch();if(Parser.endOfExpression.indexOf(n.text)!==-1){break}if(t&&n.text===t){break}if(e&&functions[n.text]&&functions[n.text].infix){break}const o=this.parseAtom(t);if(!o){break}else if(o.type==="internal"){continue}r.push(o);this.prevAtomType=o.type==="atom"?o.family:o.type}if(this.mode==="text"){this.formLigatures(r)}return this.handleInfixNodes(r)}handleInfixNodes(e){let t=-1;let r;for(let n=0;n<e.length;n++){if(e[n].type==="infix"){if(t!==-1){throw new ParseError("only one infix operator per group",e[n].token)}t=n;r=e[n].replaceWith}}if(t!==-1&&r){let n;let o;const a=e.slice(0,t);const i=e.slice(t+1);if(a.length===1&&a[0].type==="ordgroup"){n=a[0]}else{n={type:"ordgroup",mode:this.mode,body:a}}if(i.length===1&&i[0].type==="ordgroup"){o=i[0]}else{o={type:"ordgroup",mode:this.mode,body:i}}let s;if(r==="\\\\abovefrac"){s=this.callFunction(r,[n,e[t],o],[])}else{s=this.callFunction(r,[n,o],[])}return[s]}else{return e}}handleSupSubscript(e){const t=this.fetch();const r=t.text;this.consume();this.consumeSpaces();const n=this.parseGroup(e);if(!n){throw new ParseError("Expected group after '"+r+"'",t)}return n}formatUnsupportedCmd(e){const t=[];for(let r=0;r<e.length;r++){t.push({type:"textord",mode:"text",text:e[r]})}const r={type:"text",mode:this.mode,body:t};const n={type:"color",mode:this.mode,color:this.settings.errorColor,body:[r]};return n}parseAtom(e){const t=this.parseGroup("atom",e);if(this.mode==="text"){return t}let r;let n;while(true){this.consumeSpaces();const e=this.fetch();if(e.text==="\\limits"||e.text==="\\nolimits"){if(t&&t.type==="op"){const r=e.text==="\\limits";t.limits=r;t.alwaysHandleSupSub=true}else if(t&&t.type==="operatorname"){if(t.alwaysHandleSupSub){t.limits=e.text==="\\limits"}}else{throw new ParseError("Limit controls must follow a math operator",e)}this.consume()}else if(e.text==="^"){if(r){throw new ParseError("Double superscript",e)}r=this.handleSupSubscript("superscript")}else if(e.text==="_"){if(n){throw new ParseError("Double subscript",e)}n=this.handleSupSubscript("subscript")}else if(e.text==="'"){if(r){throw new ParseError("Double superscript",e)}const t={type:"textord",mode:this.mode,text:"\\prime"};const n=[t];this.consume();while(this.fetch().text==="'"){n.push(t);this.consume()}if(this.fetch().text==="^"){n.push(this.handleSupSubscript("superscript"))}r={type:"ordgroup",mode:this.mode,body:n}}else if(uSubsAndSups[e.text]){const t=unicodeSubRegEx.test(e.text);const o=[];o.push(new Token(uSubsAndSups[e.text]));this.consume();while(true){const e=this.fetch().text;if(!uSubsAndSups[e]){break}if(unicodeSubRegEx.test(e)!==t){break}o.unshift(new Token(uSubsAndSups[e]));this.consume()}const a=this.subparse(o);if(t){n={type:"ordgroup",mode:"math",body:a}}else{r={type:"ordgroup",mode:"math",body:a}}}else{break}}if(r||n){if(t&&t.type==="multiscript"&&!t.postscripts){t.postscripts={sup:r,sub:n};return t}else{return{type:"supsub",mode:this.mode,base:t,sup:r,sub:n}}}else{return t}}parseFunction(e,t){const r=this.fetch();const n=r.text;const o=functions[n];if(!o){return null}this.consume();if(t&&t!=="atom"&&!o.allowedInArgument){throw new ParseError("Got function '"+n+"' with no arguments"+(t?" as "+t:""),r)}else if(this.mode==="text"&&!o.allowedInText){throw new ParseError("Can't use function '"+n+"' in text mode",r)}else if(this.mode==="math"&&o.allowedInMath===false){throw new ParseError("Can't use function '"+n+"' in math mode",r)}const a=this.prevAtomType;const{args:i,optArgs:s}=this.parseArguments(n,o);this.prevAtomType=a;return this.callFunction(n,i,s,r,e)}callFunction(e,t,r,n,o){const a={funcName:e,parser:this,token:n,breakOnTokenText:o};const i=functions[e];if(i&&i.handler){return i.handler(a,t,r)}else{throw new ParseError(`No function handler for ${e}`)}}parseArguments(e,t){const r=t.numArgs+t.numOptionalArgs;if(r===0){return{args:[],optArgs:[]}}const n=[];const o=[];for(let a=0;a<r;a++){let r=t.argTypes&&t.argTypes[a];const i=a<t.numOptionalArgs;if(t.primitive&&r==null||t.type==="sqrt"&&a===1&&o[0]==null){r="primitive"}const s=this.parseGroupOfType(`argument to '${e}'`,r,i);if(i){o.push(s)}else if(s!=null){n.push(s)}else{throw new ParseError("Null argument, please report this as a bug")}}return{args:n,optArgs:o}}parseGroupOfType(e,t,r){switch(t){case"size":return this.parseSizeGroup(r);case"url":return this.parseUrlGroup(r);case"math":case"text":return this.parseArgumentGroup(r,t);case"hbox":{const e=this.parseArgumentGroup(r,"text");return e!=null?{type:"styling",mode:e.mode,body:[e],scriptLevel:"text"}:null}case"raw":{const e=this.parseStringGroup("raw",r);return e!=null?{type:"raw",mode:"text",string:e.text}:null}case"primitive":{if(r){throw new ParseError("A primitive argument cannot be optional")}const t=this.parseGroup(e);if(t==null){throw new ParseError("Expected group as "+e,this.fetch())}return t}case"original":case null:case undefined:return this.parseArgumentGroup(r);default:throw new ParseError("Unknown group type as "+e,this.fetch())}}consumeSpaces(){while(true){const e=this.fetch().text;if(e===" "||e==="︎"){this.consume()}else{break}}}parseStringGroup(e,t){const r=this.gullet.scanArgument(t);if(r==null){return null}let n="";let o;while((o=this.fetch()).text!=="EOF"){n+=o.text;this.consume()}this.consume();r.text=n;return r}parseRegexGroup(e,t){const r=this.fetch();let n=r;let o="";let a;while((a=this.fetch()).text!=="EOF"&&e.test(o+a.text)){n=a;o+=n.text;this.consume()}if(o===""){throw new ParseError("Invalid "+t+": '"+r.text+"'",r)}return r.range(n,o)}parseSizeGroup(e){let t;let r=false;this.gullet.consumeSpaces();if(!e&&this.gullet.future().text!=="{"){t=this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/,"size")}else{t=this.parseStringGroup("size",e)}if(!t){return null}if(!e&&t.text.length===0){t.text="0pt";r=true}const n=/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t.text);if(!n){throw new ParseError("Invalid size: '"+t.text+"'",t)}const o={number:+(n[1]+n[2]),unit:n[3]};if(!validUnit(o)){throw new ParseError("Invalid unit: '"+o.unit+"'",t)}return{type:"size",mode:this.mode,value:o,isBlank:r}}parseUrlGroup(e){this.gullet.lexer.setCatcode("%",13);this.gullet.lexer.setCatcode("~",12);const t=this.parseStringGroup("url",e);this.gullet.lexer.setCatcode("%",14);this.gullet.lexer.setCatcode("~",13);if(t==null){return null}let r=t.text.replace(/\\([#$%&~_^{}])/g,"$1");r=t.text.replace(/{\u2044}/g,"/");return{type:"url",mode:this.mode,url:r}}parseArgumentGroup(e,t){const r=this.gullet.scanArgument(e);if(r==null){return null}const n=this.mode;if(t){this.switchMode(t)}this.gullet.beginGroup();const o=this.parseExpression(false,"EOF");this.expect("EOF");this.gullet.endGroup();const a={type:"ordgroup",mode:this.mode,loc:r.loc,body:o};if(t){this.switchMode(n)}return a}parseGroup(e,t){const r=this.fetch();const n=r.text;let o;if(n==="{"||n==="\\begingroup"||n==="\\toggle"){this.consume();const e=n==="{"?"}":n==="\\begingroup"?"\\endgroup":"\\endtoggle";this.gullet.beginGroup();const t=this.parseExpression(false,e);const a=this.fetch();this.expect(e);this.gullet.endGroup();o={type:a.text==="\\endtoggle"?"toggle":"ordgroup",mode:this.mode,loc:SourceLocation.range(r,a),body:t,semisimple:n==="\\begingroup"||undefined}}else{o=this.parseFunction(t,e)||this.parseSymbol();if(o==null&&n[0]==="\\"&&!Object.prototype.hasOwnProperty.call(implicitCommands,n)){o=this.formatUnsupportedCmd(n);this.consume()}}return o}formLigatures(e){let t=e.length-1;for(let r=0;r<t;++r){const n=e[r];const o=n.text;if(o==="-"&&e[r+1].text==="-"){if(r+1<t&&e[r+2].text==="-"){e.splice(r,3,{type:"textord",mode:"text",loc:SourceLocation.range(n,e[r+2]),text:"---"});t-=2}else{e.splice(r,2,{type:"textord",mode:"text",loc:SourceLocation.range(n,e[r+1]),text:"--"});t-=1}}if((o==="'"||o==="`")&&e[r+1].text===o){e.splice(r,2,{type:"textord",mode:"text",loc:SourceLocation.range(n,e[r+1]),text:o+o});t-=1}}}parseSymbol(){const e=this.fetch();let t=e.text;if(/^\\verb[^a-zA-Z]/.test(t)){this.consume();let e=t.slice(5);const r=e.charAt(0)==="*";if(r){e=e.slice(1)}if(e.length<2||e.charAt(0)!==e.slice(-1)){throw new ParseError(`\\verb assertion failed --\n                    please report what input caused this bug`)}e=e.slice(1,-1);return{type:"verb",mode:"text",body:e,star:r}}if(Object.prototype.hasOwnProperty.call(unicodeSymbols,t[0])&&!symbols[this.mode][t[0]]){if(this.settings.strict&&this.mode==="math"){throw new ParseError(`Accented Unicode text character "${t[0]}" used in `+`math mode`,e)}t=unicodeSymbols[t[0]]+t.slice(1)}const r=combiningDiacriticalMarksEndRegex.exec(t);if(r){t=t.substring(0,r.index);if(t==="i"){t="ı"}else if(t==="j"){t="ȷ"}}let n;if(symbols[this.mode][t]){const r=symbols[this.mode][t].group;const o=SourceLocation.range(e);let a;if(Object.prototype.hasOwnProperty.call(ATOMS,r)){const e=r;a={type:"atom",mode:this.mode,family:e,loc:o,text:t}}else{if(asciiFromScript[t]){this.consume();const e=this.fetch().text.charCodeAt(0);const r=e===65025?"mathscr":"mathcal";if(e===65024||e===65025){this.consume()}return{type:"font",mode:"math",font:r,body:{type:"mathord",mode:"math",loc:o,text:asciiFromScript[t]}}}a={type:r,mode:this.mode,loc:o,text:t}}n=a}else if(!this.strict&&numberRegEx.test(t)){this.consume();return{type:"textord",mode:this.mode,loc:SourceLocation.range(e),text:t}}else if(t.charCodeAt(0)>=128){if(this.settings.strict){if(!supportedCodepoint(t.charCodeAt(0))){throw new ParseError(`Unrecognized Unicode character "${t[0]}"`+` (${t.charCodeAt(0)})`,e)}else if(this.mode==="math"){throw new ParseError(`Unicode text character "${t[0]}" used in math mode`,e)}}n={type:"textord",mode:"text",loc:SourceLocation.range(e),text:t}}else{return null}this.consume();if(r){for(let t=0;t<r[0].length;t++){const o=r[0][t];if(!unicodeAccents[o]){throw new ParseError(`Unknown accent ' ${o}'`,e)}const a=unicodeAccents[o][this.mode]||unicodeAccents[o].text;if(!a){throw new ParseError(`Accent ${o} unsupported in ${this.mode} mode`,e)}n={type:"accent",mode:this.mode,loc:SourceLocation.range(e),label:a,isStretchy:false,isShifty:true,base:n}}}return n}}const parseTree=function(e,t){if(!(typeof e==="string"||e instanceof String)){throw new TypeError("Temml can only parse string typed expression")}const r=new Parser(e,t);delete r.gullet.macros.current["\\df@tag"];let n=r.parse();if(!(n.length>0&&n[0].type&&n[0].type==="array"&&n[0].addEqnNum)){if(r.gullet.macros.get("\\df@tag")){if(!t.displayMode){throw new ParseError("\\tag works only in display mode")}r.gullet.feed("\\df@tag");n=[{type:"tag",mode:"text",body:n,tag:r.parse()}]}}return n};const subOrSupLevel=[2,2,3,3];class Style{constructor(e){this.level=e.level;this.color=e.color;this.font=e.font||"";this.fontFamily=e.fontFamily||"";this.fontSize=e.fontSize||1;this.fontWeight=e.fontWeight||"";this.fontShape=e.fontShape||"";this.maxSize=e.maxSize}extend(e){const t={level:this.level,color:this.color,font:this.font,fontFamily:this.fontFamily,fontSize:this.fontSize,fontWeight:this.fontWeight,fontShape:this.fontShape,maxSize:this.maxSize};for(const r in e){if(Object.prototype.hasOwnProperty.call(e,r)){t[r]=e[r]}}return new Style(t)}withLevel(e){return this.extend({level:e})}incrementLevel(){return this.extend({level:Math.min(this.level+1,3)})}inSubOrSup(){return this.extend({level:subOrSupLevel[this.level]})}withColor(e){return this.extend({color:e})}withFont(e){return this.extend({font:e})}withTextFontFamily(e){return this.extend({fontFamily:e,font:""})}withFontSize(e){return this.extend({fontSize:e})}withTextFontWeight(e){return this.extend({fontWeight:e,font:""})}withTextFontShape(e){return this.extend({fontShape:e,font:""})}getColor(){return this.color}}const version="0.10.0";function postProcess(e){const t={};let r=0;const n=e.getElementsByClassName("tml-tageqn");for(const e of n){const n=e.getElementsByClassName("tml-eqn");if(n.length>0){r+=1;n[0].id="tml-eqn-"+r}const o=e.getElementsByClassName("tml-label");if(o.length===0){continue}if(n.length>0){t[o[0].id]=String(r)}else{const r=e.getElementsByClassName("tml-tag");if(r.length>0){t[o[0].id]=r[0].textContent}}}const o=e.getElementsByClassName("tml-ref");[...o].forEach((e=>{let r=t[e.getAttribute("href").slice(1)];if(e.className.indexOf("tml-eqref")===-1){r=r.replace(/^\(/,"");r=r.replace(/\($/,"")}{if(r.charAt(0)!=="("){r="("+r}if(r.slice(-1)!==")"){r=r+")"}}e.textContent=r}))}let render=function(e,t,r){t.textContent="";const n=t.tagName==="MATH";if(n){r.wrap="none"}const o=renderToMathMLTree(e,r);if(n){t.textContent="";o.children.forEach((e=>{t.appendChild(e.toNode())}))}else if(o.children.length>1){t.textContent="";o.children.forEach((e=>{t.appendChild(e.toNode())}))}else{t.appendChild(o.toNode())}};if(typeof document!=="undefined"){if(document.compatMode!=="CSS1Compat"){typeof console!=="undefined"&&console.warn("Warning: Temml doesn't work in quirks mode. Make sure your "+"website has a suitable doctype.");render=function(){throw new ParseError("Temml doesn't work in quirks mode.")}}}const renderToString=function(e,t){const r=renderToMathMLTree(e,t).toMarkup();return r};const generateParseTree=function(e,t){const r=new Settings(t);return parseTree(e,r)};const definePreamble=function(e,t){const r=new Settings(t);r.macros={};if(!(typeof e==="string"||e instanceof String)){throw new TypeError("Temml can only parse string typed expression")}const n=new Parser(e,r,true);delete n.gullet.macros.current["\\df@tag"];const o=n.parse();return o};const renderError=function(e,t,r){if(r.throwOnError||!(e instanceof ParseError)){throw e}const n=new Span(["temml-error"],[new TextNode$1(t+"\n"+e.toString())]);n.style.color=r.errorColor;n.style.whiteSpace="pre-line";return n};const renderToMathMLTree=function(e,t){const r=new Settings(t);try{const t=parseTree(e,r);const n=new Style({level:r.displayMode?StyleLevel.DISPLAY:StyleLevel.TEXT,maxSize:r.maxSize});return buildMathML(t,e,n,r)}catch(t){return renderError(t,e,r)}};var temml={version:version,render:render,renderToString:renderToString,postProcess:postProcess,ParseError:ParseError,definePreamble:definePreamble,__parse:generateParseTree,__renderToMathMLTree:renderToMathMLTree,__defineSymbol:defineSymbol,__defineMacro:defineMacro};export{temml as default};