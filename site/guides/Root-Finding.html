<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Root Finding</title>
  <link rel="stylesheet" href="./styles.css">
</head>
<body>
  <nav>
   <ul>
     <li><a href="../index.html">Hurmet</a></li>
     <li><a href="../manual.html">Documentation</a></li>
   </ul>
  </nav>
<article class="ProseMirror pica">
<h2 id='root-finding'>Root Finding</h2>
<p>For finding roots of a function, <span class='hurmet-calc' data-entry='f'><math><mi>f</mi></math></span>.</p>
<p>Bisection method</p>
<div class="indented"><p>Slow but sure. Select <span class='hurmet-calc' data-entry='a'><math><mi>a</mi></math></span> and <span class='hurmet-calc' data-entry='b'><math><mi>b</mi></math></span> such that <span class='hurmet-calc' data-entry='f(a)'><math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>a</mi><mo form="postfix" stretchy="false">)</mo></mrow></math></span> and <span class='hurmet-calc' data-entry='f(b)'><math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>b</mi><mo form="postfix" stretchy="false">)</mo></mrow></math></span> have opposite signs. The optional argument ε  enables you to define a desired precision.</p></div>
<p><pre><code>function bisection(f, a, b; ε = 1e-15)
    fa = f(a)
    fb = f(b)
    if fa × fb > 0 throw "Error. Invalid starting bracket."
    while true
        x = (a + b) / 2
        fx = f(x)
        if |fx| ≤ ε return x
        if sign(fa) == sign(fx)
            a = x
        else
            b = x
        end
    end
end</code></pre></p>
<p>Newton’s method</p>
<div class="indented"><p>Much faster than bisection when it works. Sometimes it does not converge. It’s not a good idea to use Newton’s method for a periodic function. It will freeze the browser tab.</p>
<p>Input the function <em>f</em>, its first derivative <em>f</em> ′, and a starting guess. The <em>ε</em>  is optional.</p></div>
<p><pre><code>function newton(f, fPrime, guess; ε = 1e-15)
    x = guess
    while true
        fx = f(x)
        if |fx| ≤ ε return x
        x = x - fx / fPrime(x)
    end
end</code></pre></p>
<p>Brent’s method</p>
<div class="indented"><p>Converges faster than bisection. Sure to find a result, so long as the function is continuous.<br>Select <span class='hurmet-calc' data-entry='a'><math><mi>a</mi></math></span> and <span class='hurmet-calc' data-entry='b'><math><mi>b</mi></math></span> such that <span class='hurmet-calc' data-entry='f(a)'><math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>a</mi><mo form="postfix" stretchy="false">)</mo></mrow></math></span> and <span class='hurmet-calc' data-entry='f(b)'><math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>b</mi><mo form="postfix" stretchy="false">)</mo></mrow></math></span> have opposite signs.</p>
<p>Adapted from John D Cook: <a href='https://www.codeproject.com/Articles/79541/Three-Methods-for-Root-finding-in-C'>Three Methods for Root-finding in C#</a></p>
<p><pre><code>function brent(f, a, b; ε = 1e-15)
    fa = f(a)
    fb = f(b)
    if fa × fb > 0 throw "Error. Invalid starting bracket."
    c = a
    fc = fa
    e = b - a
    d = e
    while true
        if |fb| ≤ ε return b
        if (fb > 0.0 and fc > 0.0) or (fb ≤ 0.0 and fc ≤ 0.0)
            c = a
            fc = fa
            e = b - a
            d = e
        end
        if |fc| < |fb|
            a = b
            b = c
            c = a
            fa = fb
            fb = fc
            fc = fa
        end
        tol = 2 ε · |b| + ε
        m = 0.5 · (c - b)  # error estimate
        if |m| > tol and fb ≠ 0.0
            if |e| < tol or |fa| ≤ |fb|
                # Use bisection
                e = m
                d = e
            else
                s = fb / fa
                if a == c
                    # linear intepolation
                    p = 2 m s
                    q = 1.0 - s
                else
                    # Inverse quadratic interpolation
                    q = fa / fc
                    r = fb / fc
                    p = s * (2 m q * (q - r) - (b - a) * (r - 1.0))
                    q = (q - 1.0) * (r - 1.0) * (s - 1.0)
                end
                if p > 0.0
                    q = -q
                else
                    p = -p
                end
                s = e
                e = d
                if 2 p < 3 m q - |tol * q| and p < |0.5 s q|
                    d = p / q
                else
                    e = m
                    d = e
                end
            end
            a = b
            fa = fb
            if |d| > tol
                b = b + d
            elseif m > 0.0
                b = b + tol
            else
                b = b - tol
            end
            fb = f(b)
        else
          return b
        end
    end
end</code></pre></p></div>
<h2 id='examples'>Examples</h2>
<p>You can pass a function as an argument to another function. One way to do that is with arrow notation, e.g., <span class='hurmet-calc' data-entry='x → cos x'><math><mrow><mi>x</mi><mo stretchy="false">→</mo><mrow><mi>cos</mi><mo>⁡</mo><mspace width="0.1667em"></mspace></mrow><mi>x</mi></mrow></math></span>. (Note: <code>-></code> will auto-correct into →)</p>
<p>Use bisection to find a root of <span class='hurmet-calc' data-entry='cos x'><math><mrow><mrow><mi>cos</mi><mo>⁡</mo><mspace width="0.1667em"></mspace></mrow><mi>x</mi></mrow></math></span>.</p>
<div class="indented"><p><span class='hurmet-calc' data-entry='x = bisection(x → cos x, 1, 2) = %'><math><mrow><mi>x</mi><mo>=</mo><mi>bisection</mi><mo>⁡</mo><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo stretchy="false">→</mo><mrow><mi>cos</mi><mo>⁡</mo><mspace width="0.1667em"></mspace></mrow><mi>x</mi><mo separator="true">,</mo><mspace width="0.2222em"></mspace><mn>1</mn><mo separator="true">,</mo><mspace width="0.2222em"></mspace><mn>2</mn><mo form="postfix" stretchy="false">)</mo></mrow><mrow><mo>=</mo><mn>1.5707963267949</mn></mrow></math></span></p></div>
<p>Use Newton’s method to find the cube root of five.</p>
<div class="indented"><p><span class='hurmet-calc' data-entry='x = newton(x → x³ - 5, y → 3 y², 1) = ?'><math><mrow><mi>x</mi><mo>=</mo><mi>newton</mi><mo>⁡</mo><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo stretchy="false">→</mo><msup><mi>x</mi><mn>3</mn></msup><mo>−</mo><mn>5</mn><mo separator="true">,</mo><mspace width="0.2222em"></mspace><mi>y</mi><mo stretchy="false">→</mo><mn>3</mn><mspace width="0.1667em"></mspace><msup><mi>y</mi><mn>2</mn></msup><mo separator="true">,</mo><mspace width="0.2222em"></mspace><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow><mrow><mo>=</mo><mn>1.7099759466767</mn></mrow></math></span></p></div>
<p>Use Brent’s method to find a root of <span class='hurmet-calc' data-entry='cos x'><math><mrow><mrow><mi>cos</mi><mo>⁡</mo><mspace width="0.1667em"></mspace></mrow><mi>x</mi></mrow></math></span></p>
<div class="indented"><p><span class='hurmet-calc' data-entry='x = brent(x → cos x, 1, 2) = ?'><math><mrow><mi>x</mi><mo>=</mo><mi>brent</mi><mo>⁡</mo><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo stretchy="false">→</mo><mrow><mi>cos</mi><mo>⁡</mo><mspace width="0.1667em"></mspace></mrow><mi>x</mi><mo separator="true">,</mo><mspace width="0.2222em"></mspace><mn>1</mn><mo separator="true">,</mo><mspace width="0.2222em"></mspace><mn>2</mn><mo form="postfix" stretchy="false">)</mo></mrow><mrow><mo>=</mo><mn>1.5707963267949</mn></mrow></math></span></p></div>
<h2 id='remote-module'>Remote Module</h2>
<p>I’ve saved these three functions in a GitHub Gist, so you can call them without having to copy them into your document.</p>
<p>First, open a math zone (Alt-C) and copy in this code:</p>
<pre style="overflow-x: scroll;"><code>findRoot = import(&quot;https://gist.githubusercontent.com/ronkok/a6c48bbb3b65c973d7cee69f2735c42f/raw/rootFinding.txt&quot;) = !</code></pre><p>Then call a function like this example:</p>
<div class="indented"><p><span class='hurmet-calc' data-entry='x = findRoot.newton(x → x³ - 5, y → 3 y², 1) = ?'><math><mrow><mi>x</mi><mo>=</mo><mrow><mrow><mi mathvariant="normal">f</mi></mrow><mrow><mi mathvariant="normal">i</mi></mrow><mrow><mi mathvariant="normal">n</mi></mrow><mrow><mi mathvariant="normal">d</mi></mrow><mrow><mi mathvariant="normal">R</mi></mrow><mrow><mi mathvariant="normal">o</mi></mrow><mrow><mi mathvariant="normal">o</mi></mrow><mrow><mi mathvariant="normal">t</mi></mrow></mrow><mi>.</mi><mspace width="0.1667em"></mspace><mi>newton</mi><mo>⁡</mo><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo stretchy="false">→</mo><msup><mi>x</mi><mn>3</mn></msup><mo>−</mo><mn>5</mn><mo separator="true">,</mo><mspace width="0.2222em"></mspace><mi>y</mi><mo stretchy="false">→</mo><mn>3</mn><mspace width="0.1667em"></mspace><msup><mi>y</mi><mn>2</mn></msup><mo separator="true">,</mo><mspace width="0.2222em"></mspace><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow><mrow><mo>=</mo><mn>1.7099759466767</mn></mrow></math></span></p></div>

</article>
</body>
</html>